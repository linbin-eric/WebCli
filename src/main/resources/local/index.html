<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebCli Terminal - Local</title>
    <link rel="stylesheet" href="lib/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100%;
            overflow: hidden; /* 禁用页面滚动条，仅保留终端内部滚动 */
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1e1e1e;
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .toolbar {
            background: #2d2d2d;
            padding: 8px 16px;
            display: flex;
            gap: 8px;
            align-items: center;
            border-bottom: 1px solid #404040;
        }
        .toolbar button {
            background: #0e639c;
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        .toolbar button:hover { background: #1177bb; }
        .toolbar button:disabled { background: #555; cursor: not-allowed; }
        .tabs {
            display: flex;
            gap: 2px;
            margin-left: 16px;
        }
        .tab {
            background: #2d2d2d;
            color: #ccc;
            border: none;
            padding: 6px 16px;
            cursor: pointer;
            font-size: 13px;
            border-radius: 4px 4px 0 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .tab.active { background: #1e1e1e; color: #fff; }
        .tab .close {
            opacity: 0.6;
        }
        .tab .close:hover { opacity: 1; }
        .tab .remote-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #555;
        }
        .tab .remote-indicator.active {
            background: #4ec9b0;
        }
        .theme-select {
            background: #3c3c3c;
            color: #fff;
            border: 1px solid #555;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
        }
        .theme-select:hover {
            background: #4c4c4c;
        }
        .right-tools {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .remote-create-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #ccc;
            user-select: none;
        }
        .remote-create-toggle input {
            cursor: pointer;
            accent-color: #4ec9b0;
        }
        #terminal-container {
            flex: 1;
            padding: 8px;
            min-height: 0; /* 允许 flex 子项收缩，避免出现外层滚动条 */
            overflow: hidden;
        }
        .status {
            color: #888;
            font-size: 12px;
        }
        .status.connected { color: #4ec9b0; }
        .status.disconnected { color: #f14c4c; }
        .context-menu {
            position: fixed;
            background: #2d2d2d;
            border: 1px solid #404040;
            border-radius: 4px;
            padding: 4px 0;
            min-width: 150px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
        }
        .context-menu.show { display: block; }
        .context-menu-item {
            padding: 6px 16px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .context-menu-item:hover { background: #094771; }
        .context-menu-item .check {
            width: 16px;
            text-align: center;
        }
        .shortcuts {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }
        .shortcuts-toggle {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #0e639c;
            color: #fff;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        .shortcuts-toggle:hover {
            background: #1177bb;
            transform: scale(1.1);
        }
        .shortcuts-toggle:active {
            background: #0d5a8c;
            transform: scale(0.95);
        }
        .shortcuts-panel {
            position: absolute;
            bottom: 70px;
            right: 0;
            display: none;
            flex-direction: column;
            gap: 8px;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .shortcuts-panel.show {
            display: flex;
            opacity: 1;
            transform: translateY(0);
        }
        .shortcuts-panel button {
            background: #0e639c;
            color: #fff;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        .shortcuts-panel button:hover { background: #1177bb; }
        .shortcuts-panel button:active { background: #0d5a8c; }
        .arrow-keys {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            grid-template-rows: repeat(2, 40px);
            gap: 4px;
        }
        .arrow-keys button {
            padding: 8px;
            font-size: 16px;
        }
        .arrow-keys .arrow-up { grid-column: 2; grid-row: 1; }
        .arrow-keys .arrow-left { grid-column: 1; grid-row: 2; }
        .arrow-keys .arrow-down { grid-column: 2; grid-row: 2; }
        .arrow-keys .arrow-right { grid-column: 3; grid-row: 2; }
    </style>
</head>
<body>
<div class="toolbar">
    <button id="btn-new">新建终端</button>
    <div class="tabs" id="tabs"></div>
    <div class="right-tools">
        <label class="remote-create-toggle" title="允许远端通过远端 WebCli 在本机创建新终端">
            <input type="checkbox" id="remote-create-toggle">
            <span>允许远端新建</span>
        </label>
        <select class="theme-select" id="theme-select">
            <option value="dark">深色主题</option>
            <option value="light">浅色主题</option>
            <option value="eye-care">护眼主题</option>
        </select>
        <span class="status disconnected" id="status">未连接</span>
    </div>
</div>
<div id="terminal-container"></div>
<div class="context-menu" id="context-menu">
    <div class="context-menu-item" id="menu-rename">重命名</div>
    <div class="context-menu-item" id="menu-remote">
        <span class="check" id="menu-remote-check"></span>
        <span>远程可见</span>
    </div>
    <div class="context-menu-item" id="menu-close">关闭终端</div>
</div>
<div class="shortcuts">
    <button class="shortcuts-toggle" id="shortcuts-toggle" title="快捷操作">⌨️</button>
    <div class="shortcuts-panel" id="shortcuts-panel">
        <div class="arrow-keys">
            <button class="arrow-up" id="btn-arrow-up">↑</button>
            <button class="arrow-left" id="btn-arrow-left">←</button>
            <button class="arrow-down" id="btn-arrow-down">↓</button>
            <button class="arrow-right" id="btn-arrow-right">→</button>
        </div>
        <button id="btn-enter">Enter</button>
        <button id="btn-shift-enter">Shift+Enter</button>
        <button id="btn-ctrl-c">Ctrl+C</button>
        <button id="btn-ctrl-v">Ctrl+V</button>
        <button id="btn-resize">Resize</button>
    </div>
</div>

<script src="lib/xterm.min.js"></script>
<script src="lib/xterm-addon-fit.min.js"></script>
<script>
    const MessageType = {
        PTY_OUTPUT: 'PTY_OUTPUT',
        PTY_INPUT: 'PTY_INPUT',
        PTY_RESIZE: 'PTY_RESIZE',
        PTY_SWITCH: 'PTY_SWITCH',
        PTY_ATTACH: 'PTY_ATTACH',
        ERROR: 'ERROR',
        SUCCESS: 'SUCCESS'
    };

    const themes = {
        dark: {
            background: '#1e1e1e',
            foreground: '#d4d4d4',
            cursor: '#d4d4d4',
            selectionBackground: '#264f78'
        },
        light: {
            background: '#ffffff',
            foreground: '#333333',
            cursor: '#333333',
            selectionBackground: '#add6ff',
            black: '#000000',
            red: '#c91b00',
            green: '#00a000',
            yellow: '#a08000',
            blue: '#0225c7',
            magenta: '#c930c7',
            cyan: '#00a0a0',
            white: '#555555',
            brightBlack: '#676767',
            brightRed: '#ff6d67',
            brightGreen: '#00c200',
            brightYellow: '#c7c400',
            brightBlue: '#6871ff',
            brightMagenta: '#ff76ff',
            brightCyan: '#00c5c7',
            brightWhite: '#333333'
        },
        'eye-care': {
            background: '#f5f0e1',
            foreground: '#5b4636',
            cursor: '#5b4636',
            selectionBackground: '#d4c4a8',
            black: '#000000',
            red: '#c91b00',
            green: '#00a000',
            yellow: '#a08000',
            blue: '#0225c7',
            magenta: '#c930c7',
            cyan: '#00a0a0',
            white: '#555555',
            brightBlack: '#676767',
            brightRed: '#ff6d67',
            brightGreen: '#00c200',
            brightYellow: '#c0a000',
            brightBlue: '#6871ff',
            brightMagenta: '#ff76ff',
            brightCyan: '#00a0a0',
            brightWhite: '#333333'
        }
    };

    class WebCliTerminal {
        constructor() {
            this.ws = null;
            this.terminals = new Map();
            this.fitAddons = new Map();
            this.terminalNames = new Map();
            this.terminalRemoteViewable = new Map();
            this.terminalRemoteCreated = new Map();
            this.currentPtyId = null;
            this.nextTerminalNumber = 1;
            this.contextMenuPtyId = null;
            this.currentTheme = localStorage.getItem('webcli-theme') || 'dark';
            this.syncTimer = null;

            this.init();
        }

        init() {
            this.connect();
            this.initContextMenu();
            this.initShortcuts();
            this.initThemeSelector();
            this.initRemoteCreateToggle();

            document.getElementById('btn-new').addEventListener('click', () => this.createPty());
            window.addEventListener('resize', () => this.fitTerminal());
        }

        initThemeSelector() {
            const selector = document.getElementById('theme-select');
            selector.value = this.currentTheme;
            selector.addEventListener('change', (e) => {
                this.currentTheme = e.target.value;
                localStorage.setItem('webcli-theme', this.currentTheme);
                this.applyTheme();
            });
        }

        applyTheme() {
            const theme = themes[this.currentTheme];
            // 更新页面背景
            document.body.style.background = theme.background;
            document.getElementById('terminal-container').style.background = theme.background;
            // 更新所有终端的主题
            this.terminals.forEach((term) => {
                term.options.theme = theme;
            });
        }

        initRemoteCreateToggle() {
            const toggle = document.getElementById('remote-create-toggle');
            if (!toggle) return;

            const load = async () => {
                try {
                    const response = await fetch('/api/remote-create/status');
                    const result = await response.json();
                    if (result.success) {
                        toggle.checked = !!result.data;
                    }
                } catch (e) {
                    console.error('获取远端新建开关失败:', e);
                }
            };

            toggle.addEventListener('change', async () => {
                const desired = toggle.checked;
                try {
                    const response = await fetch('/api/remote-create', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ enabled: desired })
                    });
                    const result = await response.json();
                    if (result.success) {
                        toggle.checked = !!result.data;
                    } else {
                        toggle.checked = !desired;
                        alert('设置失败: ' + (result.message || 'unknown'));
                    }
                } catch (e) {
                    toggle.checked = !desired;
                    console.error('设置远端新建开关失败:', e);
                    alert('设置失败');
                }
            });

            load();
        }

        initShortcuts() {
            let hideTimer = null;
            const panel = document.getElementById('shortcuts-panel');
            const toggle = document.getElementById('shortcuts-toggle');

            const resetHideTimer = () => {
                if (hideTimer) clearTimeout(hideTimer);
                hideTimer = setTimeout(() => {
                    panel.classList.remove('show');
                }, 15000);
            };

            toggle.addEventListener('click', () => {
                const isShown = panel.classList.contains('show');
                if (isShown) {
                    panel.classList.remove('show');
                    if (hideTimer) clearTimeout(hideTimer);
                } else {
                    panel.classList.add('show');
                    resetHideTimer();
                }
            });

            // 点击面板内的按钮时重置计时器
            panel.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    resetHideTimer();
                }
            });

            document.getElementById('btn-arrow-up').addEventListener('click', () => {
                if (this.currentPtyId) {
                    const encoded = btoa('\x1b[A');
                    this.send({ type: MessageType.PTY_INPUT, ptyId: this.currentPtyId, data: encoded });
                }
            });

            document.getElementById('btn-arrow-down').addEventListener('click', () => {
                if (this.currentPtyId) {
                    const encoded = btoa('\x1b[B');
                    this.send({ type: MessageType.PTY_INPUT, ptyId: this.currentPtyId, data: encoded });
                }
            });

            document.getElementById('btn-arrow-right').addEventListener('click', () => {
                if (this.currentPtyId) {
                    const encoded = btoa('\x1b[C');
                    this.send({ type: MessageType.PTY_INPUT, ptyId: this.currentPtyId, data: encoded });
                }
            });

            document.getElementById('btn-arrow-left').addEventListener('click', () => {
                if (this.currentPtyId) {
                    const encoded = btoa('\x1b[D');
                    this.send({ type: MessageType.PTY_INPUT, ptyId: this.currentPtyId, data: encoded });
                }
            });

            document.getElementById('btn-enter').addEventListener('click', () => {
                if (this.currentPtyId) {
                    const encoded = btoa('\r');
                    this.send({ type: MessageType.PTY_INPUT, ptyId: this.currentPtyId, data: encoded });
                }
            });

            document.getElementById('btn-shift-enter').addEventListener('click', () => {
                if (this.currentPtyId) {
                    const encoded = btoa('\n');
                    this.send({ type: MessageType.PTY_INPUT, ptyId: this.currentPtyId, data: encoded });
                }
            });

            document.getElementById('btn-ctrl-c').addEventListener('click', () => {
                if (this.currentPtyId) {
                    const encoded = btoa('\x03');
                    this.send({ type: MessageType.PTY_INPUT, ptyId: this.currentPtyId, data: encoded });
                }
            });

            document.getElementById('btn-ctrl-v').addEventListener('click', async () => {
                try {
                    const text = await navigator.clipboard.readText();
                    if (this.currentPtyId && text) {
                        const encoded = btoa(unescape(encodeURIComponent(text)));
                        this.send({ type: MessageType.PTY_INPUT, ptyId: this.currentPtyId, data: encoded });
                    }
                } catch (e) {
                    console.error('粘贴失败:', e);
                }
            });

            document.getElementById('btn-resize').addEventListener('click', () => {
                this.fitTerminal(true);
            });
        }

        initContextMenu() {
            const menu = document.getElementById('context-menu');

            document.addEventListener('click', (e) => {
                if (!menu.contains(e.target)) {
                    this.hideContextMenu();
                }
            });

            document.getElementById('menu-rename').addEventListener('click', (e) => {
                e.stopPropagation();
                const ptyId = this.contextMenuPtyId;
                this.hideContextMenu();
                if (ptyId) {
                    this.showRenameDialog(ptyId);
                }
            });

            document.getElementById('menu-remote').addEventListener('click', (e) => {
                e.stopPropagation();
                const ptyId = this.contextMenuPtyId;
                this.hideContextMenu();
                if (ptyId) {
                    this.toggleRemoteViewable(ptyId);
                }
            });

            document.getElementById('menu-close').addEventListener('click', (e) => {
                e.stopPropagation();
                const ptyId = this.contextMenuPtyId;
                this.hideContextMenu();
                if (ptyId) {
                    this.closePty(ptyId);
                }
            });
        }

        showContextMenu(e, ptyId) {
            e.preventDefault();
            this.contextMenuPtyId = ptyId;
            const menu = document.getElementById('context-menu');
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';

            // 更新远程可见状态
            const isRemote = this.terminalRemoteViewable.get(ptyId) || false;
            document.getElementById('menu-remote-check').textContent = isRemote ? '✓' : '';

            menu.classList.add('show');
        }

        hideContextMenu() {
            document.getElementById('context-menu').classList.remove('show');
            this.contextMenuPtyId = null;
        }

        showRenameDialog(ptyId) {
            const currentName = this.terminalNames.get(ptyId) || '';
            const newName = prompt('请输入新的终端名称:', currentName);
            if (newName === null) return;
            const trimmedName = newName.trim();
            if (trimmedName === '') {
                alert('终端名称不能为空');
                return;
            }
            if (trimmedName === currentName) return;
            for (const [id, name] of this.terminalNames) {
                if (id !== ptyId && name === trimmedName) {
                    alert('终端名称已存在，请使用其他名称');
                    return;
                }
            }
            this.renamePty(ptyId, trimmedName);
        }

        renamePty(ptyId, newName) {
            fetch(`/api/terminal/${ptyId}/name`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newName })
            })
            .then(response => response.json())
            .then(result => {
                if (result.success && result.data) {
                    this.terminalNames.set(ptyId, result.data.name);
                    this.updateTab(ptyId);
                } else {
                    console.error('重命名失败:', result.message);
                    alert('重命名失败: ' + result.message);
                }
            })
            .catch(e => {
                console.error('重命名失败:', e);
                alert('重命名失败');
            });
        }

        toggleRemoteViewable(ptyId) {
            const current = this.terminalRemoteViewable.get(ptyId) || false;
            fetch(`/api/terminal/${ptyId}/visibility`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ remoteViewable: !current })
            })
            .then(response => response.json())
            .then(result => {
                if (result.success && result.data) {
                    this.terminalRemoteViewable.set(ptyId, result.data.remoteViewable);
                    this.updateTab(ptyId);
                } else {
                    console.error('设置远程可见性失败:', result.message);
                }
            })
            .catch(e => console.error('设置远程可见性失败:', e));
        }

        updateTab(ptyId) {
            const tab = document.querySelector(`.tab[data-pty-id="${ptyId}"]`);
            if (tab) {
                const name = this.terminalNames.get(ptyId) || '';
                const isRemote = this.terminalRemoteViewable.get(ptyId) || false;
                tab.innerHTML = `
                    <span class="remote-indicator ${isRemote ? 'active' : ''}"></span>
                    <span class="tab-name">${name}</span>
                    <span class="close">×</span>
                `;
            }
        }

        connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${location.host}/ws`;
            this.ws = new WebSocket(wsUrl);

            this.ws.onopen = () => {
                this.updateStatus(true);
                this.loadTerminalList();
                this.startTerminalSync();
            };

            this.ws.onmessage = (e) => {
                this.handleMessage(JSON.parse(e.data));
            };

            this.ws.onclose = () => {
                this.updateStatus(false);
                this.stopTerminalSync();
                setTimeout(() => this.connect(), 3000);
            };

            this.ws.onerror = (e) => console.error('WebSocket error:', e);
        }

        startTerminalSync() {
            if (this.syncTimer) return;
            this.syncTimer = setInterval(() => this.syncTerminalList(), 2000);
        }

        stopTerminalSync() {
            if (this.syncTimer) {
                clearInterval(this.syncTimer);
                this.syncTimer = null;
            }
        }

        async syncTerminalList() {
            try {
                const response = await fetch('/api/terminals');
                const result = await response.json();
                if (result.success && Array.isArray(result.data)) {
                    this.applyTerminalList(result.data);
                }
            } catch (e) {
                // 静默失败，下一轮继续
            }
        }

        applyTerminalList(list) {
            const aliveIds = new Set();
            for (const ptyInfo of list) {
                if (!ptyInfo || !ptyInfo.id) continue;
                if (!ptyInfo.alive) continue;
                const ptyId = ptyInfo.id;
                aliveIds.add(ptyId);

                const name = ptyInfo.name || ptyId;
                const remoteViewable = !!ptyInfo.remoteViewable;
                const remoteCreated = !!ptyInfo.remoteCreated;

                if (!this.terminals.has(ptyId)) {
                    this.terminalRemoteViewable.set(ptyId, remoteViewable);
                    this.terminalRemoteCreated.set(ptyId, remoteCreated);
                    const shouldSwitch = this.terminals.size === 0;
                    this.attachPty(ptyId, name, shouldSwitch);
                    continue;
                }

                if (this.terminalNames.get(ptyId) !== name) {
                    this.terminalNames.set(ptyId, name);
                    this.updateTab(ptyId);
                }
                if ((this.terminalRemoteViewable.get(ptyId) || false) !== remoteViewable) {
                    this.terminalRemoteViewable.set(ptyId, remoteViewable);
                    this.updateTab(ptyId);
                }
                if ((this.terminalRemoteCreated.get(ptyId) || false) !== remoteCreated) {
                    this.terminalRemoteCreated.set(ptyId, remoteCreated);
                }
            }

            // 清理已不存在/已退出的终端
            for (const ptyId of Array.from(this.terminals.keys())) {
                if (!aliveIds.has(ptyId)) {
                    this.removeTerminalUi(ptyId);
                }
            }
        }

        removeTerminalUi(ptyId) {
            this.terminals.get(ptyId)?.dispose();
            this.terminals.delete(ptyId);
            this.fitAddons.delete(ptyId);
            this.terminalNames.delete(ptyId);
            this.terminalRemoteViewable.delete(ptyId);
            this.terminalRemoteCreated.delete(ptyId);
            document.querySelector(`.tab[data-pty-id="${ptyId}"]`)?.remove();

            if (this.currentPtyId === ptyId) {
                const firstPty = this.terminals.keys().next().value;
                if (firstPty) {
                    this.switchTerminal(firstPty);
                } else {
                    this.currentPtyId = null;
                    document.getElementById('terminal-container').innerHTML = '';
                }
            }
        }

        async loadTerminalList() {
            try {
                const response = await fetch('/api/terminals');
                const result = await response.json();
                if (result.success && result.data) {
                    this.handlePtyList(result.data);
                } else {
                    console.error('获取终端列表失败:', result.message);
                    this.createPty();
                }
            } catch (e) {
                console.error('获取终端列表失败:', e);
                this.createPty();
            }
        }

        handleMessage(msg) {
            switch (msg.type) {
                case MessageType.PTY_OUTPUT:
                    if (msg.ptyId && msg.data) {
                        const decoded = atob(msg.data);
                        const bytes = Uint8Array.from(decoded, c => c.charCodeAt(0));
                        const text = new TextDecoder('utf-8').decode(bytes);
                        const term = this.terminals.get(msg.ptyId);
                        if (term) {
                            term.write(text);
                        }
                    }
                    break;
                case MessageType.SUCCESS:
                    // WebSocket 只处理 attach 成功的响应
                    break;
                case MessageType.ERROR:
                    console.error('Server error:', msg.data);
                    break;
            }
        }

        handlePtyList(list) {
            if (list && list.length > 0) {
                list.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
                list.forEach((ptyInfo, index) => {
                    if (ptyInfo.alive) {
                        this.terminalRemoteViewable.set(ptyInfo.id, ptyInfo.remoteViewable || false);
                        this.terminalRemoteCreated.set(ptyInfo.id, ptyInfo.remoteCreated || false);
                        this.attachPty(ptyInfo.id, ptyInfo.name, index === 0);
                    }
                });
                this.updateNextTerminalNumber();
            } else {
                this.createPty();
            }
        }

        updateNextTerminalNumber() {
            let maxNumber = 0;
            this.terminalNames.forEach(name => {
                const match = name.match(/^终端 (\d+)$/);
                if (match) {
                    maxNumber = Math.max(maxNumber, parseInt(match[1]));
                }
            });
            this.nextTerminalNumber = maxNumber + 1;
        }

        attachPty(ptyId, name, switchTo) {
            this.addTerminal(ptyId, name, switchTo);
            this.send({ type: MessageType.PTY_ATTACH, ptyId });
        }

        async createPty() {
            const name = `终端 ${this.nextTerminalNumber++}`;
            try {
                const response = await fetch('/api/terminal', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                const result = await response.json();
                if (result.success && result.data) {
                    const ptyInfo = result.data;
                    this.terminalRemoteViewable.set(ptyInfo.id, ptyInfo.remoteViewable || false);
                    this.terminalRemoteCreated.set(ptyInfo.id, ptyInfo.remoteCreated || false);
                    this.addTerminal(ptyInfo.id, ptyInfo.name, true);
                    this.send({ type: MessageType.PTY_ATTACH, ptyId: ptyInfo.id });
                    this.updateNextTerminalNumber();
                } else {
                    console.error('创建终端失败:', result.message);
                    alert('创建终端失败: ' + result.message);
                    this.nextTerminalNumber--;
                }
            } catch (e) {
                console.error('创建终端失败:', e);
                alert('创建终端失败');
                this.nextTerminalNumber--;
            }
        }

        addTerminal(ptyId, name, switchTo = true) {
            const theme = themes[this.currentTheme];
            const term = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: '"Maple Mono NF", "MesloLGS NF", "Hack Nerd Font", Menlo, Monaco, "Courier New", monospace',
                theme: theme,
                scrollback: 5000,
                smoothScrollDuration: 0
            });

            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            this.terminals.set(ptyId, term);
            this.fitAddons.set(ptyId, fitAddon);
            this.terminalNames.set(ptyId, name);

            // 用于跟踪 Shift+Enter 是否刚被处理过
            let skipNextEnterData = false;
            // 输入合并：将极短时间内的多次 onData 事件合并为一次发送
            let inputBuffer = '';
            let inputTimer = null;

            term.onData(data => {
                // 如果刚处理过 Shift+Enter，跳过 onData 产生的回车数据
                if (skipNextEnterData && (data === '\r' || data === '\n')) {
                    skipNextEnterData = false;
                    return;
                }
                skipNextEnterData = false;
                inputBuffer += data;
                if (inputTimer) clearTimeout(inputTimer);
                inputTimer = setTimeout(() => {
                    const toSend = inputBuffer;
                    inputBuffer = '';
                    inputTimer = null;
                    const encoded = btoa(unescape(encodeURIComponent(toSend)));
                    this.send({ type: MessageType.PTY_INPUT, ptyId, data: encoded });
                }, 5);
            });

            // 自定义按键处理：Shift+Enter 发送与 Alt+Enter 相同的转义序列
            term.attachCustomKeyEventHandler((ev) => {
                if (ev.type === 'keydown' && ev.key === 'Enter' && ev.shiftKey && !ev.ctrlKey && !ev.altKey && !ev.metaKey) {
                    // Shift+Enter: 发送 ESC + CR (与 Alt+Enter 相同的序列)
                    const encoded = btoa('\x1b\r');
                    this.send({ type: MessageType.PTY_INPUT, ptyId, data: encoded });
                    skipNextEnterData = true; // 标记跳过下一个 onData 中的回车
                    return false; // 阻止默认处理
                }
                return true; // 其他按键正常处理
            });

            term.onResize(({ cols, rows }) => {
                this.send({ type: MessageType.PTY_RESIZE, ptyId, cols, rows });
                console.log(`终端尺寸变化: ${cols}x${rows}`);
            });

            this.addTab(ptyId, name);
            if (switchTo) {
                this.switchTerminal(ptyId);
            }
        }

        addTab(ptyId, name) {
            const tabs = document.getElementById('tabs');
            const tab = document.createElement('button');
            tab.className = 'tab';
            tab.dataset.ptyId = ptyId;
            const isRemote = this.terminalRemoteViewable.get(ptyId) || false;
            tab.innerHTML = `
                <span class="remote-indicator ${isRemote ? 'active' : ''}"></span>
                <span class="tab-name">${name}</span>
                <span class="close">×</span>
            `;

            tab.addEventListener('click', (e) => {
                if (e.target.classList.contains('close')) {
                    e.stopPropagation();
                    this.closePty(ptyId);
                } else {
                    this.switchTerminal(ptyId);
                }
            });

            tab.addEventListener('contextmenu', (e) => {
                this.showContextMenu(e, ptyId);
            });

            tabs.appendChild(tab);
        }

        switchTerminal(ptyId) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[data-pty-id="${ptyId}"]`)?.classList.add('active');

            const container = document.getElementById('terminal-container');
            container.innerHTML = '';

            const term = this.terminals.get(ptyId);
            const fitAddon = this.fitAddons.get(ptyId);
            if (term && fitAddon) {
                term.open(container);
                fitAddon.fit();
                term.focus();
                this.currentPtyId = ptyId;

                console.log(`切换到终端 ${ptyId}，尺寸: ${term.cols}x${term.rows}`);
            }
        }

        async closePty(ptyId) {
            // 本地端直接关闭终端，不需要确认
            await this.closeTerminalBoth(ptyId);
        }

        async closeTerminalBoth(ptyId) {
            fetch(`/api/terminal/${ptyId}`, { method: 'DELETE' })
                .then(response => response.json())
                .then(result => {
                    if (!result.success) {
                        console.error('关闭终端失败:', result.message);
                    }
                })
                .catch(e => console.error('关闭终端失败:', e));

            this.terminals.get(ptyId)?.dispose();
            this.terminals.delete(ptyId);
            this.fitAddons.delete(ptyId);
            this.terminalNames.delete(ptyId);
            this.terminalRemoteViewable.delete(ptyId);
            this.terminalRemoteCreated.delete(ptyId);

            document.querySelector(`.tab[data-pty-id="${ptyId}"]`)?.remove();

            if (this.currentPtyId === ptyId) {
                const firstPty = this.terminals.keys().next().value;
                if (firstPty) this.switchTerminal(firstPty);
            }
        }

        fitTerminal(force = false) {
            if (this.currentPtyId) {
                const fitAddon = this.fitAddons.get(this.currentPtyId);
                const term = this.terminals.get(this.currentPtyId);
                if (fitAddon && term) {
                    fitAddon.fit();
                    if (force) {
                        // 强制发送当前尺寸到后端，覆盖可能被远端改变的 PTY winSize
                        this.send({ type: MessageType.PTY_RESIZE, ptyId: this.currentPtyId, cols: term.cols, rows: term.rows });
                    }
                    console.log(`窗口调整，终端尺寸: ${term.cols}x${term.rows}`);
                }
            }
        }

        send(msg) {
            if (this.ws?.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify(msg));
            }
        }

        updateStatus(connected) {
            const status = document.getElementById('status');
            status.textContent = connected ? '已连接' : '未连接';
            status.className = `status ${connected ? 'connected' : 'disconnected'}`;
        }
    }

    new WebCliTerminal();
</script>
</body>
</html>
