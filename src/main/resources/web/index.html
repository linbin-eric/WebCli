<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebCli Terminal</title>
    <link rel="stylesheet" href="lib/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1e1e1e;
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .toolbar {
            background: #2d2d2d;
            padding: 8px 16px;
            display: flex;
            gap: 8px;
            align-items: center;
            border-bottom: 1px solid #404040;
        }
        .toolbar button {
            background: #0e639c;
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        .toolbar button:hover { background: #1177bb; }
        .toolbar button:disabled { background: #555; cursor: not-allowed; }
        .tabs {
            display: flex;
            gap: 2px;
            margin-left: 16px;
        }
        .tab {
            background: #2d2d2d;
            color: #ccc;
            border: none;
            padding: 6px 16px;
            cursor: pointer;
            font-size: 13px;
            border-radius: 4px 4px 0 0;
        }
        .tab.active { background: #1e1e1e; color: #fff; }
        .tab .close {
            margin-left: 8px;
            opacity: 0.6;
        }
        .tab .close:hover { opacity: 1; }
        #terminal-container {
            flex: 1;
            padding: 8px;
        }
        .status {
            color: #888;
            font-size: 12px;
            margin-left: auto;
        }
        .status.connected { color: #4ec9b0; }
        .status.disconnected { color: #f14c4c; }
        .context-menu {
            position: fixed;
            background: #2d2d2d;
            border: 1px solid #404040;
            border-radius: 4px;
            padding: 4px 0;
            min-width: 120px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
        }
        .context-menu.show { display: block; }
        .context-menu-item {
            padding: 6px 16px;
            cursor: pointer;
            font-size: 13px;
        }
        .context-menu-item:hover { background: #094771; }
    </style>
</head>
<body>
<div class="toolbar">
    <button id="btn-new">新建终端</button>
    <div class="tabs" id="tabs"></div>
    <span class="status disconnected" id="status">未连接</span>
</div>
<div id="terminal-container"></div>
<div class="context-menu" id="context-menu">
    <div class="context-menu-item" id="menu-rename">重命名</div>
    <div class="context-menu-item" id="menu-close">关闭终端</div>
</div>

<script src="lib/xterm.min.js"></script>
<script src="lib/xterm-addon-fit.min.js"></script>
<script>
    const MessageType = {
        PTY_OUTPUT: 'PTY_OUTPUT',
        PTY_INPUT: 'PTY_INPUT',
        PTY_RESIZE: 'PTY_RESIZE',
        PTY_CREATE: 'PTY_CREATE',
        PTY_CLOSE: 'PTY_CLOSE',
        PTY_LIST: 'PTY_LIST',
        PTY_SWITCH: 'PTY_SWITCH',
        PTY_ATTACH: 'PTY_ATTACH',
        PTY_RENAME: 'PTY_RENAME',
        ERROR: 'ERROR',
        SUCCESS: 'SUCCESS'
    };

    class WebCliTerminal {
        constructor() {
            this.ws = null;
            this.terminals = new Map();
            this.fitAddons = new Map();
            this.terminalNames = new Map();
            this.currentPtyId = null;
            this.nextTerminalNumber = 1;
            this.contextMenuPtyId = null;

            this.init();
        }

        init() {
            this.connect();
            this.initContextMenu();

            document.getElementById('btn-new').addEventListener('click', () => this.createPty());
            window.addEventListener('resize', () => this.fitTerminal());
        }

        initContextMenu() {
            const menu = document.getElementById('context-menu');

            // 点击其他地方关闭菜单
            document.addEventListener('click', (e) => {
                if (!menu.contains(e.target)) {
                    this.hideContextMenu();
                }
            });

            // 重命名
            document.getElementById('menu-rename').addEventListener('click', (e) => {
                e.stopPropagation();
                const ptyId = this.contextMenuPtyId;
                this.hideContextMenu();
                if (ptyId) {
                    this.showRenameDialog(ptyId);
                }
            });

            // 关闭终端
            document.getElementById('menu-close').addEventListener('click', (e) => {
                e.stopPropagation();
                const ptyId = this.contextMenuPtyId;
                this.hideContextMenu();
                if (ptyId) {
                    this.closePty(ptyId);
                }
            });
        }

        showContextMenu(e, ptyId) {
            e.preventDefault();
            this.contextMenuPtyId = ptyId;
            const menu = document.getElementById('context-menu');
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';
            menu.classList.add('show');
        }

        hideContextMenu() {
            document.getElementById('context-menu').classList.remove('show');
            this.contextMenuPtyId = null;
        }

        showRenameDialog(ptyId) {
            const currentName = this.terminalNames.get(ptyId) || '';
            const newName = prompt('请输入新的终端名称:', currentName);
            if (newName === null) {
                return; // 用户取消
            }
            const trimmedName = newName.trim();
            if (trimmedName === '') {
                alert('终端名称不能为空');
                return;
            }
            if (trimmedName === currentName) {
                return; // 名称未变化
            }
            // 检查名称是否重复
            for (const [id, name] of this.terminalNames) {
                if (id !== ptyId && name === trimmedName) {
                    alert('终端名称已存在，请使用其他名称');
                    return;
                }
            }
            this.renamePty(ptyId, trimmedName);
        }

        renamePty(ptyId, newName) {
            this.send({ type: MessageType.PTY_RENAME, ptyId, name: newName });
            // 立即更新本地
            this.terminalNames.set(ptyId, newName);
            this.updateTabName(ptyId, newName);
        }

        updateTabName(ptyId, name) {
            const tab = document.querySelector(`.tab[data-pty-id="${ptyId}"]`);
            if (tab) {
                tab.innerHTML = `<span class="tab-name">${name}</span><span class="close">×</span>`;
            }
        }

        connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${location.host}/ws`;
            console.log('Connecting to WebSocket:', wsUrl);
            this.ws = new WebSocket(wsUrl);

            this.ws.onopen = () => {
                console.log('WebSocket connected');
                this.updateStatus(true);
                // 连接后先获取已有终端列表
                this.send({ type: MessageType.PTY_LIST });
            };

            this.ws.onmessage = (e) => {
                console.log('WebSocket message received:', e.data);
                this.handleMessage(JSON.parse(e.data));
            };

            this.ws.onclose = (e) => {
                console.log('WebSocket closed:', e.code, e.reason);
                this.updateStatus(false);
                setTimeout(() => this.connect(), 3000);
            };

            this.ws.onerror = (e) => console.error('WebSocket error:', e);
        }

        handleMessage(msg) {
            switch (msg.type) {
                case MessageType.PTY_OUTPUT:
                    const term = this.terminals.get(msg.ptyId);
                    if (term && msg.data) {
                        const decoded = atob(msg.data);
                        const bytes = Uint8Array.from(decoded, c => c.charCodeAt(0));
                        const text = new TextDecoder('utf-8').decode(bytes);
                        term.write(text);
                    }
                    break;
                case MessageType.PTY_LIST:
                    // 处理终端列表响应
                    this.handlePtyList(msg.data);
                    break;
                case MessageType.SUCCESS:
                    if (msg.ptyId && !this.terminals.has(msg.ptyId)) {
                        // 新创建的终端，使用服务端返回的名称
                        this.addTerminal(msg.ptyId, msg.name);
                        this.updateNextTerminalNumber();
                    }
                    break;
                case MessageType.ERROR:
                    console.error('Server error:', msg.data);
                    break;
            }
        }

        handlePtyList(data) {
            const list = JSON.parse(data);
            if (list && list.length > 0) {
                // 有已存在的终端，逐个恢复
                // 先按名称排序，确保顺序一致
                list.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
                list.forEach((ptyInfo, index) => {
                    if (ptyInfo.alive) {
                        this.attachPty(ptyInfo.id, ptyInfo.name, index === 0);
                    }
                });
                // 更新下一个终端编号
                this.updateNextTerminalNumber();
            } else {
                // 没有已存在的终端，创建新终端
                this.createPty();
            }
        }

        updateNextTerminalNumber() {
            // 从现有终端名称中找出最大编号
            let maxNumber = 0;
            this.terminalNames.forEach(name => {
                const match = name.match(/^终端 (\d+)$/);
                if (match) {
                    maxNumber = Math.max(maxNumber, parseInt(match[1]));
                }
            });
            this.nextTerminalNumber = maxNumber + 1;
        }

        attachPty(ptyId, name, switchTo) {
            // 先创建本地终端
            this.addTerminal(ptyId, name, switchTo);
            // 发送 attach 请求，获取历史输出
            this.send({ type: MessageType.PTY_ATTACH, ptyId });
        }

        createPty() {
            const name = `终端 ${this.nextTerminalNumber++}`;
            this.send({ type: MessageType.PTY_CREATE, name });
        }

        addTerminal(ptyId, name, switchTo = true) {
            const term = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: '"Maple Mono NF", "MesloLGS NF", "Hack Nerd Font", Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#1e1e1e',
                    foreground: '#d4d4d4'
                }
            });

            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            this.terminals.set(ptyId, term);
            this.fitAddons.set(ptyId, fitAddon);
            this.terminalNames.set(ptyId, name);

            term.onData(data => {
                // 将输入数据进行 Base64 编码，避免 JSON 转义问题
                const encoded = btoa(unescape(encodeURIComponent(data)));
                this.send({ type: MessageType.PTY_INPUT, ptyId, data: encoded });
            });

            term.onResize(({ cols, rows }) => {
                this.send({ type: MessageType.PTY_RESIZE, ptyId, cols, rows });
            });

            this.addTab(ptyId, name);
            if (switchTo) {
                this.switchTerminal(ptyId);
            }
        }

        addTab(ptyId, name) {
            const tabs = document.getElementById('tabs');
            const tab = document.createElement('button');
            tab.className = 'tab';
            tab.dataset.ptyId = ptyId;
            tab.innerHTML = `<span class="tab-name">${name}</span><span class="close">×</span>`;

            tab.addEventListener('click', (e) => {
                if (e.target.classList.contains('close')) {
                    this.closePty(ptyId);
                } else {
                    this.switchTerminal(ptyId);
                }
            });

            // 右键菜单
            tab.addEventListener('contextmenu', (e) => {
                this.showContextMenu(e, ptyId);
            });

            tabs.appendChild(tab);
        }

        switchTerminal(ptyId) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[data-pty-id="${ptyId}"]`)?.classList.add('active');

            const container = document.getElementById('terminal-container');
            container.innerHTML = '';

            const term = this.terminals.get(ptyId);
            const fitAddon = this.fitAddons.get(ptyId);
            if (term && fitAddon) {
                term.open(container);
                fitAddon.fit();
                term.focus();
                this.currentPtyId = ptyId;

                this.send({
                    type: MessageType.PTY_RESIZE,
                    ptyId,
                    cols: term.cols,
                    rows: term.rows
                });
            }
        }

        closePty(ptyId) {
            this.send({ type: MessageType.PTY_CLOSE, ptyId });
            this.terminals.get(ptyId)?.dispose();
            this.terminals.delete(ptyId);
            this.fitAddons.delete(ptyId);
            this.terminalNames.delete(ptyId);

            document.querySelector(`.tab[data-pty-id="${ptyId}"]`)?.remove();

            if (this.currentPtyId === ptyId) {
                const firstPty = this.terminals.keys().next().value;
                if (firstPty) this.switchTerminal(firstPty);
            }
        }

        fitTerminal() {
            if (this.currentPtyId) {
                const fitAddon = this.fitAddons.get(this.currentPtyId);
                const term = this.terminals.get(this.currentPtyId);
                if (fitAddon && term) {
                    fitAddon.fit();
                    this.send({
                        type: MessageType.PTY_RESIZE,
                        ptyId: this.currentPtyId,
                        cols: term.cols,
                        rows: term.rows
                    });
                }
            }
        }

        send(msg) {
            if (this.ws?.readyState === WebSocket.OPEN) {
                const json = JSON.stringify(msg);
                console.log('WebSocket sending:', json);
                this.ws.send(json);
            } else {
                console.warn('WebSocket not open, cannot send:', msg);
            }
        }

        updateStatus(connected) {
            const status = document.getElementById('status');
            status.textContent = connected ? '已连接' : '未连接';
            status.className = `status ${connected ? 'connected' : 'disconnected'}`;
        }
    }

    new WebCliTerminal();
</script>
</body>
</html>
