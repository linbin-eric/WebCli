<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebCli Terminal</title>
    <link rel="stylesheet" href="lib/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1e1e1e;
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .toolbar {
            background: #2d2d2d;
            padding: 8px 16px;
            display: flex;
            gap: 8px;
            align-items: center;
            border-bottom: 1px solid #404040;
        }
        .toolbar button {
            background: #0e639c;
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        .toolbar button:hover { background: #1177bb; }
        .toolbar button:disabled { background: #555; cursor: not-allowed; }
        .tabs {
            display: flex;
            gap: 2px;
            margin-left: 16px;
        }
        .tab {
            background: #2d2d2d;
            color: #ccc;
            border: none;
            padding: 6px 16px;
            cursor: pointer;
            font-size: 13px;
            border-radius: 4px 4px 0 0;
        }
        .tab.active { background: #1e1e1e; color: #fff; }
        .tab .close {
            margin-left: 8px;
            opacity: 0.6;
        }
        .tab .close:hover { opacity: 1; }
        #terminal-container {
            flex: 1;
            padding: 8px;
        }
        .status {
            color: #888;
            font-size: 12px;
            margin-left: auto;
        }
        .status.connected { color: #4ec9b0; }
        .status.disconnected { color: #f14c4c; }
    </style>
</head>
<body>
<div class="toolbar">
    <button id="btn-new">新建终端</button>
    <div class="tabs" id="tabs"></div>
    <span class="status disconnected" id="status">未连接</span>
</div>
<div id="terminal-container"></div>

<script src="lib/xterm.min.js"></script>
<script src="lib/xterm-addon-fit.min.js"></script>
<script>
    const MessageType = {
        PTY_OUTPUT: 'PTY_OUTPUT',
        PTY_INPUT: 'PTY_INPUT',
        PTY_RESIZE: 'PTY_RESIZE',
        PTY_CREATE: 'PTY_CREATE',
        PTY_CLOSE: 'PTY_CLOSE',
        PTY_LIST: 'PTY_LIST',
        PTY_SWITCH: 'PTY_SWITCH',
        ERROR: 'ERROR',
        SUCCESS: 'SUCCESS'
    };

    class WebCliTerminal {
        constructor() {
            this.ws = null;
            this.terminals = new Map();
            this.fitAddons = new Map();
            this.currentPtyId = null;

            this.init();
        }

        init() {
            this.connect();

            document.getElementById('btn-new').addEventListener('click', () => this.createPty());
            window.addEventListener('resize', () => this.fitTerminal());
        }

        connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${location.host}/ws`;
            console.log('Connecting to WebSocket:', wsUrl);
            this.ws = new WebSocket(wsUrl);

            this.ws.onopen = () => {
                console.log('WebSocket connected');
                this.updateStatus(true);
                this.createPty();
            };

            this.ws.onmessage = (e) => {
                console.log('WebSocket message received:', e.data);
                this.handleMessage(JSON.parse(e.data));
            };

            this.ws.onclose = (e) => {
                console.log('WebSocket closed:', e.code, e.reason);
                this.updateStatus(false);
                setTimeout(() => this.connect(), 3000);
            };

            this.ws.onerror = (e) => console.error('WebSocket error:', e);
        }

        handleMessage(msg) {
            switch (msg.type) {
                case MessageType.PTY_OUTPUT:
                    const term = this.terminals.get(msg.ptyId);
                    if (term && msg.data) {
                        const decoded = atob(msg.data);
                        const bytes = Uint8Array.from(decoded, c => c.charCodeAt(0));
                        const text = new TextDecoder('utf-8').decode(bytes);
                        term.write(text);
                    }
                    break;
                case MessageType.SUCCESS:
                    if (msg.ptyId && !this.terminals.has(msg.ptyId)) {
                        this.addTerminal(msg.ptyId);
                    }
                    break;
                case MessageType.ERROR:
                    console.error('Server error:', msg.data);
                    break;
            }
        }

        createPty() {
            this.send({ type: MessageType.PTY_CREATE });
        }

        addTerminal(ptyId) {
            const term = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: '"Maple Mono NF", "MesloLGS NF", "Hack Nerd Font", Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#1e1e1e',
                    foreground: '#d4d4d4'
                }
            });

            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            this.terminals.set(ptyId, term);
            this.fitAddons.set(ptyId, fitAddon);

            term.onData(data => {
                // 将输入数据进行 Base64 编码，避免 JSON 转义问题
                const encoded = btoa(unescape(encodeURIComponent(data)));
                this.send({ type: MessageType.PTY_INPUT, ptyId, data: encoded });
            });

            term.onResize(({ cols, rows }) => {
                this.send({ type: MessageType.PTY_RESIZE, ptyId, cols, rows });
            });

            this.addTab(ptyId);
            this.switchTerminal(ptyId);
        }

        addTab(ptyId) {
            const tabs = document.getElementById('tabs');
            const tab = document.createElement('button');
            tab.className = 'tab';
            tab.dataset.ptyId = ptyId;
            tab.innerHTML = `终端 ${this.terminals.size}<span class="close">×</span>`;

            tab.addEventListener('click', (e) => {
                if (e.target.classList.contains('close')) {
                    this.closePty(ptyId);
                } else {
                    this.switchTerminal(ptyId);
                }
            });

            tabs.appendChild(tab);
        }

        switchTerminal(ptyId) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[data-pty-id="${ptyId}"]`)?.classList.add('active');

            const container = document.getElementById('terminal-container');
            container.innerHTML = '';

            const term = this.terminals.get(ptyId);
            const fitAddon = this.fitAddons.get(ptyId);
            if (term && fitAddon) {
                term.open(container);
                fitAddon.fit();
                term.focus();
                this.currentPtyId = ptyId;

                this.send({
                    type: MessageType.PTY_RESIZE,
                    ptyId,
                    cols: term.cols,
                    rows: term.rows
                });
            }
        }

        closePty(ptyId) {
            this.send({ type: MessageType.PTY_CLOSE, ptyId });
            this.terminals.get(ptyId)?.dispose();
            this.terminals.delete(ptyId);
            this.fitAddons.delete(ptyId);

            document.querySelector(`.tab[data-pty-id="${ptyId}"]`)?.remove();

            if (this.currentPtyId === ptyId) {
                const firstPty = this.terminals.keys().next().value;
                if (firstPty) this.switchTerminal(firstPty);
            }
        }

        fitTerminal() {
            if (this.currentPtyId) {
                const fitAddon = this.fitAddons.get(this.currentPtyId);
                const term = this.terminals.get(this.currentPtyId);
                if (fitAddon && term) {
                    fitAddon.fit();
                    this.send({
                        type: MessageType.PTY_RESIZE,
                        ptyId: this.currentPtyId,
                        cols: term.cols,
                        rows: term.rows
                    });
                }
            }
        }

        send(msg) {
            if (this.ws?.readyState === WebSocket.OPEN) {
                const json = JSON.stringify(msg);
                console.log('WebSocket sending:', json);
                this.ws.send(json);
            } else {
                console.warn('WebSocket not open, cannot send:', msg);
            }
        }

        updateStatus(connected) {
            const status = document.getElementById('status');
            status.textContent = connected ? '已连接' : '未连接';
            status.className = `status ${connected ? 'connected' : 'disconnected'}`;
        }
    }

    new WebCliTerminal();
</script>
</body>
</html>
