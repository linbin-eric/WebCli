# 详细步骤

> 本文档引用了《开发指导.md》，按步骤说明每个代码改动点的具体内容。

---

## 步骤 1：修改 SessionInfo 记录结构

**文件**: `src/main/java/cc/jfire/webcli/server/LoginManager.java`

**改动位置**: `SessionInfo` 记录类（约 295 行）

**改动内容**:
将 `createTime` 字段改为 `lastActiveTime`，用于记录最后活跃时间。

```java
// 原代码
public record SessionInfo(String clientIp, long createTime) {}

// 改为
public record SessionInfo(String clientIp, long lastActiveTime) {}
```

---

## 步骤 2：修改 SESSION_DURATION_MS 常量

**文件**: `src/main/java/cc/jfire/webcli/server/LoginManager.java`

**改动位置**: 常量定义区（约 24 行）

**改动内容**:
将 Session 有效期从 24 小时改为 30 分钟。

```java
// 原代码
private static final long SESSION_DURATION_MS = 24 * 60 * 60 * 1000; // Session 有效期：24小时

// 改为
private static final long SESSION_DURATION_MS = 30 * 60 * 1000; // Session 有效期：30分钟
```

---

## 步骤 3：修改 validateSession 方法实现滑动过期

**文件**: `src/main/java/cc/jfire/webcli/server/LoginManager.java`

**改动位置**: `validateSession()` 方法（约 189-208 行）

**改动内容**:
验证成功时更新 `lastActiveTime`，实现滑动过期时间。需要将 sessions Map 的 value 改为可变对象，或使用 `compute` 方法原子更新。

```java
// 原代码
public boolean validateSession(String token) {
    if (token == null) {
        return false;
    }
    SessionInfo session = sessions.get(token);
    if (session == null) {
        return false;
    }
    // 检查是否过期
    if (System.currentTimeMillis() - session.createTime > SESSION_DURATION_MS) {
        sessions.remove(token);
        log.info("Session 已过期: token={}", token.substring(0, 8) + "...");
        return false;
    }
    return true;
}

// 改为
public boolean validateSession(String token) {
    if (token == null) {
        return false;
    }
    SessionInfo session = sessions.get(token);
    if (session == null) {
        return false;
    }
    long now = System.currentTimeMillis();
    // 检查是否过期（从最后活跃时间计算）
    if (now - session.lastActiveTime() > SESSION_DURATION_MS) {
        sessions.remove(token);
        log.info("Session 已过期: token={}", token.substring(0, 8) + "...");
        return false;
    }
    // 更新最后活跃时间
    sessions.put(token, new SessionInfo(session.clientIp(), now));
    return true;
}
```

---

## 步骤 4：修改 createSession 方法

**文件**: `src/main/java/cc/jfire/webcli/server/LoginManager.java`

**改动位置**: `createSession()` 方法（约 170-181 行）

**改动内容**:
创建 Session 时使用 `lastActiveTime` 字段。

```java
// 原代码
SessionInfo session = new SessionInfo(clientIp, System.currentTimeMillis());

// 改为（无需改动，只是确认字段名语义变化）
SessionInfo session = new SessionInfo(clientIp, System.currentTimeMillis());
```

注：由于步骤 1 已将字段从 `createTime` 改为 `lastActiveTime`，此处代码形式不变，但语义已改变。

---

## 步骤 5：增加 Pipeline 到 token 的映射

**文件**: `src/main/java/cc/jfire/webcli/server/LoginManager.java`

**改动位置**: 字段定义区（约 29-34 行之间）

**改动内容**:
新增一个 Map 保存 Pipeline ID 与 token 的映射关系。

```java
// 在 authenticatedPipelines 字段后新增
// Pipeline ID -> Session token 的映射
private final Map<String, String> pipelineTokenMap = new ConcurrentHashMap<>();
```

---

## 步骤 6：修改 authenticateByToken 方法

**文件**: `src/main/java/cc/jfire/webcli/server/LoginManager.java`

**改动位置**: `authenticateByToken()` 方法（约 245-253 行）

**改动内容**:
认证成功时保存 Pipeline 与 token 的映射。

```java
// 原代码
public boolean authenticateByToken(String pipelineId, String token) {
    if (validateSession(token)) {
        authenticatedPipelines.add(pipelineId);
        return true;
    }
    return false;
}

// 改为
public boolean authenticateByToken(String pipelineId, String token) {
    if (validateSession(token)) {
        authenticatedPipelines.add(pipelineId);
        pipelineTokenMap.put(pipelineId, token);
        return true;
    }
    return false;
}
```

---

## 步骤 7：修改 removeAuthentication 方法

**文件**: `src/main/java/cc/jfire/webcli/server/LoginManager.java`

**改动位置**: `removeAuthentication()` 方法（约 159-162 行）

**改动内容**:
移除认证状态时同时移除 Pipeline-token 映射。

```java
// 原代码
public void removeAuthentication(String pipelineId) {
    authenticatedPipelines.remove(pipelineId);
}

// 改为
public void removeAuthentication(String pipelineId) {
    authenticatedPipelines.remove(pipelineId);
    pipelineTokenMap.remove(pipelineId);
}
```

---

## 步骤 8：新增 refreshSessionByPipeline 方法

**文件**: `src/main/java/cc/jfire/webcli/server/LoginManager.java`

**改动位置**: `authenticateByToken()` 方法后（约 254 行之后）

**改动内容**:
新增方法，通过 Pipeline ID 刷新关联 Session 的活跃时间，返回是否仍有效。

```java
/**
 * 通过 Pipeline ID 刷新关联 Session 的活跃时间
 *
 * @param pipelineId Pipeline ID
 * @return Session 是否仍有效
 */
public boolean refreshSessionByPipeline(String pipelineId) {
    String token = pipelineTokenMap.get(pipelineId);
    if (token == null) {
        return false;
    }
    return validateSession(token);
}
```

---

## 步骤 9：创建 AOP 切面类

**文件**: `src/main/java/cc/jfire/webcli/server/RemoteAuthAspect.java`（新建）

**改动内容**:
创建 AOP 切面类，拦截 `RemoteTerminalController` 的所有方法进行 token 验证。

```java
package cc.jfire.webcli.server;

import cc.jfire.baseutil.Resource;
import cc.jfire.boot.http.HttpRequestExtend;
import cc.jfire.jfire.core.aop.ProceedPoint;
import cc.jfire.jfire.core.aop.notated.Around;
import cc.jfire.jfire.core.aop.notated.EnhanceClass;
import cc.jfire.webcli.web.dto.ApiResponse;
import cc.jfire.webcli.web.dto.LoginResponse;
import lombok.extern.slf4j.Slf4j;

/**
 * 远端 HTTP API 认证切面
 * 拦截 RemoteTerminalController 的方法进行 token 验证
 */
@EnhanceClass("cc.jfire.webcli.server.RemoteTerminalController")
@Slf4j
public class RemoteAuthAspect {

    @Resource
    private LoginManager loginManager;

    @Around("*(*)")
    public Object checkAuth(ProceedPoint point) throws Throwable {
        String methodName = point.getMethod().methodName();

        // 登录和验证接口不需要 token 验证
        if ("login".equals(methodName) || "validateToken".equals(methodName)) {
            return point.proceed();
        }

        // 从参数中查找 HttpRequestExtend
        HttpRequestExtend request = null;
        for (Object arg : point.getArgs()) {
            if (arg instanceof HttpRequestExtend) {
                request = (HttpRequestExtend) arg;
                break;
            }
        }

        if (request == null) {
            log.warn("方法 {} 未找到 HttpRequestExtend 参数", methodName);
            return point.proceed();
        }

        // 获取并验证 token
        String token = getAuthToken(request);
        if (token == null || !loginManager.validateSession(token)) {
            // 根据方法返回类型返回错误
            Class<?> returnType = point.getMethod().getReturnType();
            if (LoginResponse.class.isAssignableFrom(returnType)) {
                return LoginResponse.error("未登录或登录已过期");
            }
            return ApiResponse.error("未登录或登录已过期");
        }

        // token 有效，执行原方法
        return point.proceed();
    }

    private String getAuthToken(HttpRequestExtend request) {
        // 从 Authorization header 获取 token
        String auth = request.getHeaders() != null ? request.getHeaders().get("Authorization") : null;
        if (auth != null && auth.startsWith("Bearer ")) {
            return auth.substring(7);
        }
        // 也支持从 URL 参数获取
        Object tokenParam = request.getParamMap() != null ? request.getParamMap().get("token") : null;
        if (tokenParam != null) {
            return tokenParam.toString();
        }
        return null;
    }
}
```

---

## 步骤 10：移除 RemoteTerminalController 中的重复 token 验证

**文件**: `src/main/java/cc/jfire/webcli/server/RemoteTerminalController.java`

**改动位置**: 各方法内部的 token 验证代码

**改动内容**:
移除 `listAgents()`、`listTerminals()`、`createTerminal()`、`closeTerminal()`、`renameTerminal()` 方法中的 token 验证代码块。

### 10.1 listAgents 方法（约 33-50 行）

```java
// 删除以下代码块（约 44-48 行）
String token = getAuthToken(request);
if (token == null || !loginManager.validateSession(token)) {
    return ApiResponse.error("未登录或登录已过期");
}
```

### 10.2 listTerminals 方法（约 86-109 行）

```java
// 删除以下代码块（约 96-99 行）
String token = getAuthToken(request);
if (token == null || !loginManager.validateSession(token)) {
    return ApiResponse.error("未登录或登录已过期");
}
```

### 10.3 createTerminal 方法（约 115-165 行）

```java
// 删除以下代码块（约 126-130 行）
String token = getAuthToken(request);
if (token == null || !loginManager.validateSession(token)) {
    return ApiResponse.error("未登录或登录已过期");
}
```

### 10.4 closeTerminal 方法（约 171-203 行）

```java
// 删除以下代码块（约 181-184 行）
String token = getAuthToken(request);
if (token == null || !loginManager.validateSession(token)) {
    return ApiResponse.error("未登录或登录已过期");
}
```

### 10.5 renameTerminal 方法（约 209-266 行）

```java
// 删除以下代码块（约 220-224 行）
String token = getAuthToken(request);
if (token == null || !loginManager.validateSession(token)) {
    return ApiResponse.error("未登录或登录已过期");
}
```

### 10.6 移除 getAuthToken 私有方法

由于 token 验证已移至 AOP 切面，`getAuthToken()` 方法不再需要，可以删除（约 305-317 行）。但保留 `getClientIp()` 方法供 `login()` 方法使用。

---

## 步骤 11：修改 RemoteWebSocketHandler 验证 token 有效性

**文件**: `src/main/java/cc/jfire/webcli/server/RemoteWebSocketHandler.java`

**改动位置**: `handleMessage()` 方法（约 51-79 行），在 `isAuthenticated` 检查之后（约 66 行之后）

**改动内容**:
在验证 Pipeline 已认证后，增加调用 `refreshSessionByPipeline()` 检查并刷新 Session 活跃时间。如果 Session 已过期，发送 `AUTH_FAILED` 消息并清除认证状态。

```java
// 原代码（约 62-66 行）
// 其他消息需要先验证是否已登录
if (!loginManager.isAuthenticated(pipelineId)) {
    sendLoginRequired(pipeline);
    return;
}

// 改为
// 其他消息需要先验证是否已登录
if (!loginManager.isAuthenticated(pipelineId)) {
    sendLoginRequired(pipeline);
    return;
}

// 检查关联的 Session 是否仍有效（同时刷新活跃时间）
if (!loginManager.refreshSessionByPipeline(pipelineId)) {
    // Session 已过期，清除认证状态并通知前端
    loginManager.removeAuthentication(pipelineId);
    sendSessionExpired(pipeline);
    return;
}
```

**新增方法**: 在 `sendLoginRequired()` 方法后（约 112 行之后）新增 `sendSessionExpired()` 方法：

```java
/**
 * 发送 Session 已过期的消息
 */
private void sendSessionExpired(Pipeline pipeline) {
    WsMessage msg = new WsMessage();
    msg.setType(MessageType.AUTH_FAILED);
    msg.setData("登录已过期，请重新登录");
    sendMessage(pipeline, msg);
}

---

## 步骤 12：前端 HTTP 错误处理增加登录过期检测并刷新页面

**文件**: `src/main/resources/remote/index.html`

**改动位置**: `handleAuthFailed()` 方法（约 1089-1099 行）

**改动内容**:
根据文档目标"30 分钟之后完全无操作，则页面登录失效，页面自动刷新"，修改 `handleAuthFailed()` 方法，在 Session 过期时自动刷新页面而非仅显示登录对话框。

```javascript
// 原代码
handleAuthFailed(message) {
    this.wsAuthenticated = false;
    this.stopTerminalSync();
    // token 无效，清除并显示登录对话框
    this.authToken = null;
    localStorage.removeItem('webcli-auth-token');
    this.showLoginDialog();
    if (message && message !== '请先登录') {
        document.getElementById('login-error').textContent = message;
    }
}

// 改为
handleAuthFailed(message) {
    this.wsAuthenticated = false;
    this.stopTerminalSync();
    // token 无效，清除 token
    this.authToken = null;
    localStorage.removeItem('webcli-auth-token');

    // 如果是登录过期，自动刷新页面
    if (message && (message.includes('过期') || message.includes('expired'))) {
        alert('登录已过期，页面将自动刷新');
        location.reload();
        return;
    }

    // 其他情况显示登录对话框
    this.showLoginDialog();
    if (message && message !== '请先登录') {
        document.getElementById('login-error').textContent = message;
    }
}
```

**说明**:
- 当收到包含"过期"关键字的错误消息时，自动刷新页面
- 其他情况（如首次访问无 token）仍显示登录对话框
- 刷新页面前显示提示信息，让用户知道发生了什么

---

## 步骤 13：验证并测试

1. 启动应用，打开远端页面
2. 登录后等待 30 分钟无操作，验证 Session 是否过期
3. 登录后持续操作，验证 Session 是否保持有效
4. 验证 HTTP API 和 WebSocket 消息都能正确刷新 Session 活跃时间
5. 验证 token 过期后前端能正确处理并刷新页面
