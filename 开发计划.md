# 目标

1. 实现总体计划中的 P1阶段内容，也就是要有：
   1. 本地 web 界面对终端可以右键设置为可以被远程查看到的属性，如果存在这个属性，则远端 web 界面可以获取这个终端的信息，也可以操作这个终端。
   2. 开发远端 web 界面。
   3. 远端服务只能获取允许被获取的终端，可以进行输入，关闭，改变大小等。
   4. 远端服务和本地 Agent 通过 TCP 链接，保持在线方式。

# 核心思路

## 整体架构

采用"本地 Agent + 远端 WebServer"的架构模式：

1. **本地 Agent**：运行在用户本地机器上，管理 PTY 终端实例，提供本地 Web 界面
2. **远端 WebServer**：部署在公网服务器上，接受本地 Agent 的 TCP 连接，提供远端 Web 界面
3. **通信方式**：本地 Agent 主动连接远端 WebServer（类似内网穿透模式，本地无需公网 IP）

## 终端共享机制

1. 本地 Web 界面可以通过右键菜单设置终端的"可远程查看"属性
2. 只有被标记为"可远程查看"的终端才能被远端 Web 界面访问与控制（输入/关闭/调整大小等）
3. 该属性只在内存中保存，Agent 重启后自动清除

## 安全机制

1. **Token(PSK) 认证**：Token 作为预共享密钥（PSK）使用，不在网络中明文传输，通过随机数 + HMAC 完成身份认证
2. **会话密钥协商**：每次 TCP 连接使用一次性（ephemeral）密钥协商出随机会话密钥
3. **数据加密**：认证完成后，所有业务数据使用会话密钥进行加密传输

## 代码复用

远端服务和本地 Agent 共用同一个代码库，通过配置文件区分运行模式。

# 详细实现思路

## 配置扩展

扩展现有的 `WebCliConfig` 类，增加以下配置项：
- `mode`: 运行模式，支持 `agent`（本地 Agent）和 `server`（远端 WebServer）
- `token`: 用于 Agent 和 WebServer 之间认证的预共享密钥（PSK，不在网络中明文传输）
- `serverHost`: 远端 WebServer 的主机地址（Agent 模式使用）
- `serverPort`: 远端 WebServer 的 TCP 端口（Agent 模式使用）
- `tcpPort`: TCP 监听端口（Server 模式使用）

## PtyInstance 扩展

在 `PtyInstance` 类中增加以下功能：

### 远程可见属性
增加"可远程查看"属性（`remoteViewable`），该属性：
- 默认值为 `false`
- 只在内存中保存，不持久化
- 通过新增的 `PTY_SET_REMOTE_VIEWABLE` 消息类型设置

### 多输出监听器支持
将原有的单个 `outputConsumer` 改为支持多个输出监听器的列表，以支持：
- 本地 WebSocket 和远端 TCP 同时接收 PTY 输出
- 本地和远端都可以进行输入操作，PTY 的 `write` 方法本身支持多方输入
- 使用 `CopyOnWriteArrayList` 保证线程安全

## TCP 通信协议

Agent 与 WebServer 之间使用 TCP 长连接通信，采用“长度字段分帧 +（握手明文 JSON / 握手后加密负载）”的方式。

### 分帧格式

```
+----------------+------------------------+
| TotalLen (4B)  | Payload (TotalLen-4B)  |
+----------------+------------------------+
```

- `TotalLen`：4 字节整型，表示整个帧的总长度（包含 `TotalLen` 自身）。
- `Payload`：
  - 认证完成前：UTF-8 JSON（`TcpMessage`）。
  - 认证完成后：`AES-256-GCM` 加密后的字节（由 `AesGcmCrypto` 产生：`IV(12B) + Ciphertext+Tag`）。
- 说明：`TcpMessage.type` 作为消息类型字段，不再额外使用 1 字节类型头。

### 消息类型定义（TcpMessageType）

| 名称 | 方向 | 说明 |
|------|------|------|
| AUTH_REQUEST | Agent→Server | 发起认证（不传 Token，携带随机数/公钥/MAC） |
| AUTH_RESPONSE | Server→Agent | 返回认证响应（携带随机数/公钥/MAC） |
| AUTH_FINISH | Agent→Server | 认证完成确认（基于会话密钥的 MAC） |
| PTY_LIST_REQUEST | Server→Agent | 请求可远程查看的终端列表 |
| PTY_LIST_RESPONSE | Agent→Server | 返回终端列表（仅 remoteViewable=true） |
| PTY_OUTPUT | Agent→Server | 终端输出数据 |
| PTY_INPUT | Server→Agent | 终端输入数据 |
| PTY_RESIZE | Server→Agent | 调整终端大小 |
| PTY_CLOSE | Server→Agent | 关闭终端 |
| HEARTBEAT | 双向 | 心跳消息 |
| PTY_ATTACH | Server→Agent | 附加到终端 |
| PTY_DETACH | Server→Agent | 从终端分离 |

## 加密与认证机制

目标：
1. `token` 作为预共享密钥（PSK）使用，不在网络中明文传输。
2. 每次连接使用随机会话密钥（会话级别 AES Key），避免复用长期密钥。
3. 认证过程需抵抗抓包重放与中间人篡改（在不引入 TLS 的前提下）。

### 会话密钥协商（建议：X25519 + HMAC-SHA256）

- 双方预先共享 `token`（高强度随机字符串，建议 ≥ 32 字节随机值再 Base64/Hex 存储）。
- 握手阶段使用一次性（ephemeral）X25519 密钥对进行 ECDH，生成 `sharedSecret`。
- 使用 `HMAC-SHA256` 做握手认证与密钥派生（以下 `||` 表示拼接；公钥/随机数均以 Base64 字符串参与拼接）：
  - `clientMac = HMAC(token, "AUTH_REQUEST" || agentId || clientPubKey || clientNonce)`
  - `serverMac = HMAC(token, "AUTH_RESPONSE" || agentId || serverPubKey || serverNonce || clientPubKey || clientNonce)`
  - `sessionKey = HMAC(token, sharedSecret || clientNonce || serverNonce)`（取 32 字节作为 AES-256 Key）
  - `finishMac = HMAC(sessionKey, "AUTH_FINISH" || agentId)`

说明：token 若为弱口令，抓包后可被离线穷举验证（对比 HMAC 结果）。因此 token 必须是高熵随机值，并避免在日志中输出握手明文内容。

### 认证流程

1. Agent 生成 `clientNonce` 与 `clientPubKey`，计算 `clientMac`，发送 `AUTH_REQUEST`（JSON 明文）。
2. Server 校验 `clientMac`，生成 `serverNonce` 与 `serverPubKey`，计算 `serverMac` 与 `sessionKey`，返回 `AUTH_RESPONSE`（JSON 明文）。
3. Agent 校验 `serverMac`，计算 `sessionKey`，发送 `AUTH_FINISH`（JSON 明文，携带 `finishMac`）。
4. Server 校验 `finishMac` 成功后，标记连接已认证并注册 Agent；从此双方开始对业务消息 `Payload` 做 AES-GCM 加密。

### 通信加密（AES-256-GCM）

- 认证完成后，所有业务消息（PTY_*、HEARTBEAT 等）都使用 `sessionKey` 加密。
- 每条消息随机生成 12 字节 IV，密文采用 `IV + Ciphertext+Tag` 方式拼接传输。

## 前端扩展

### 本地 Web 界面扩展

在现有的右键菜单中增加"设置可远程查看"选项：
- 显示当前状态（已开启/已关闭）
- 点击切换状态
- 发送 `PTY_SET_REMOTE_VIEWABLE` 消息到后端

### 远端 Web 界面

创建新的远端 Web 界面 `remote/index.html`：
- 只显示标记为"可远程查看"的终端
- 支持输入、关闭、调整大小操作
- 不支持创建新终端
- 不支持设置"可远程查看"属性

## 架构图

```
┌─────────────────────────────────────────────────────────────────────┐
│                          本地机器                                    │
│  ┌─────────────────┐     ┌──────────────────────────────────────┐  │
│  │ 本地浏览器       │ WS  │            本地 Agent                 │  │
│  │ (local/index.html)│◄───►│  ┌────────────┐  ┌────────────────┐  │  │
│  └─────────────────┘     │  │ PtyManager │  │ AgentTcpClient │──┼──┼──┐
│                          │  └────────────┘  └────────────────┘  │  │  │
│                          └──────────────────────────────────────┘  │  │
└─────────────────────────────────────────────────────────────────────┘  │
                                                                          │
                                    TCP (加密)                             │
                                                                          │
┌─────────────────────────────────────────────────────────────────────┐  │
│                         远端服务器                                    │  │
│  ┌─────────────────┐     ┌──────────────────────────────────────┐  │  │
│  │ 远端浏览器       │ WS  │          远端 WebServer               │  │  │
│  │ (remote/index.html)│◄───►│  ┌──────────────┐  ┌──────────────┐  │◄─┼──┘
│  └─────────────────┘     │  │ AgentManager │  │ TcpServer    │  │  │
│                          │  └──────────────┘  └──────────────┘  │  │
│                          └──────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

# 实施步骤

## 步骤 1：扩展配置类

**文件**: `src/main/java/cc/jfire/webcli/config/WebCliConfig.java`

```java
// 在现有字段后添加
private String mode = "agent";  // 运行模式: agent 或 server
private String token;           // 预共享密钥(PSK)，不在网络中明文传输
private String serverHost;      // 远端服务器地址 (Agent 模式)
private int serverPort = 9090;  // 远端服务器 TCP 端口 (Agent 模式)
private int tcpPort = 9090;     // TCP 监听端口 (Server 模式)
private int webPort = 18080;    // Web 服务端口

public boolean isServerMode() {
    return "server".equalsIgnoreCase(mode);
}

public boolean isAgentMode() {
    return "agent".equalsIgnoreCase(mode) || mode == null;
}
```

## 步骤 2：扩展 PtyInstance 添加远程可见属性和多输出监听器

**文件**: `src/main/java/cc/jfire/webcli/pty/PtyInstance.java`

在 import 部分添加：

```java
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
```

将原有的 `outputConsumer` 字段替换为监听器列表：

```java
// 删除原有的：
// private volatile Consumer<String> outputConsumer;

// 替换为：
private final List<Consumer<String>> outputListeners = new CopyOnWriteArrayList<>();
private volatile boolean remoteViewable = false;
```

删除原有的 `setOutputConsumer` 方法，添加新方法：

```java
public void addOutputListener(Consumer<String> listener) {
    outputListeners.add(listener);
}

public void removeOutputListener(Consumer<String> listener) {
    outputListeners.remove(listener);
}

public boolean isRemoteViewable() {
    return remoteViewable;
}

public void setRemoteViewable(boolean remoteViewable) {
    this.remoteViewable = remoteViewable;
}
```

修改 `startReading` 方法中的输出分发逻辑：

```java
public void startReading() {
    readThread = Thread.startVirtualThread(() -> {
        try {
            byte[] buffer = new byte[1024];
            int len;
            while (running && (len = inputStream.read(buffer)) != -1) {
                String output = new String(buffer, 0, len, StandardCharsets.UTF_8);
                log.debug("PTY 输出: {}", output.length() > 100 ? output.substring(0, 100) + "..." : output);
                // 保存到历史缓冲区
                synchronized (outputHistory) {
                    outputHistory.append(output);
                    // 如果超过最大大小，截断前面的内容
                    if (outputHistory.length() > MAX_HISTORY_SIZE) {
                        outputHistory.delete(0, outputHistory.length() - MAX_HISTORY_SIZE);
                    }
                }
                // 通知所有监听器
                for (Consumer<String> listener : outputListeners) {
                    try {
                        listener.accept(output);
                    } catch (Exception e) {
                        log.error("输出监听器处理失败", e);
                    }
                }
            }
        } catch (IOException e) {
            if (running) {
                log.error("读取 PTY 输出失败", e);
            }
        }
    });
}
```

## 步骤 3：扩展消息类型

**文件**: `src/main/java/cc/jfire/webcli/protocol/MessageType.java`

```java
// 在现有枚举值后添加
PTY_SET_REMOTE_VIEWABLE,  // 设置终端可远程查看属性
PTY_REMOTE_LIST           // 获取可远程查看的终端列表
```

## 步骤 4：扩展 WsMessage 添加远程可见字段

**文件**: `src/main/java/cc/jfire/webcli/protocol/WsMessage.java`

```java
// 在现有字段后添加
private Boolean remoteViewable;
```

## 步骤 5：扩展 PtyInfo 添加远程可见字段

**文件**: `src/main/java/cc/jfire/webcli/protocol/PtyInfo.java`

```java
// 修改构造函数和字段
private boolean remoteViewable;

public PtyInfo(String id, String name, boolean alive, boolean remoteViewable) {
    this.id = id;
    this.name = name;
    this.alive = alive;
    this.remoteViewable = remoteViewable;
}
```

## 步骤 6：创建 TCP 通信协议类

**文件**: `src/main/java/cc/jfire/webcli/protocol/TcpMessageType.java`

```java
package cc.jfire.webcli.protocol;

public enum TcpMessageType {
    AUTH_REQUEST,
    AUTH_RESPONSE,
    AUTH_FINISH,
    PTY_LIST_REQUEST,
    PTY_LIST_RESPONSE,
    PTY_OUTPUT,
    PTY_INPUT,
    PTY_RESIZE,
    PTY_CLOSE,
    HEARTBEAT,
    PTY_ATTACH,
    PTY_DETACH
}
```

**文件**: `src/main/java/cc/jfire/webcli/protocol/TcpMessage.java`

```java
package cc.jfire.webcli.protocol;

import lombok.Data;

@Data
public class TcpMessage {
    private TcpMessageType type;
    // 握手字段（Base64 字符串）
    private String clientNonce;
    private String serverNonce;
    private String clientPubKey;
    private String serverPubKey;
    private String clientMac;
    private String serverMac;
    private String finishMac;

    private String ptyId;
    private String data;
    private Integer cols;
    private Integer rows;
    private String agentId;  // Agent 标识
}
```

## 步骤 7：创建加密工具类

**文件**: `src/main/java/cc/jfire/webcli/crypto/AesGcmCrypto.java`

```java
package cc.jfire.webcli.crypto;

import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;

public class AesGcmCrypto {
    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 128;

    private final SecretKeySpec secretKey;
    private final SecureRandom secureRandom = new SecureRandom();

    public AesGcmCrypto(byte[] key) {
        if (key.length != 32) {
            throw new IllegalArgumentException("Key must be 256 bits (32 bytes)");
        }
        this.secretKey = new SecretKeySpec(key, "AES");
    }

    public byte[] encrypt(byte[] plaintext) throws Exception {
        byte[] iv = new byte[GCM_IV_LENGTH];
        secureRandom.nextBytes(iv);

        Cipher cipher = Cipher.getInstance(ALGORITHM);
        GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, parameterSpec);

        byte[] ciphertext = cipher.doFinal(plaintext);

        // IV + ciphertext
        byte[] result = new byte[iv.length + ciphertext.length];
        System.arraycopy(iv, 0, result, 0, iv.length);
        System.arraycopy(ciphertext, 0, result, iv.length, ciphertext.length);

        return result;
    }

    public byte[] decrypt(byte[] encrypted) throws Exception {
        byte[] iv = new byte[GCM_IV_LENGTH];
        System.arraycopy(encrypted, 0, iv, 0, iv.length);

        byte[] ciphertext = new byte[encrypted.length - iv.length];
        System.arraycopy(encrypted, iv.length, ciphertext, 0, ciphertext.length);

        Cipher cipher = Cipher.getInstance(ALGORITHM);
        GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
        cipher.init(Cipher.DECRYPT_MODE, secretKey, parameterSpec);

        return cipher.doFinal(ciphertext);
    }

    public static byte[] generateKey() {
        byte[] key = new byte[32];
        new SecureRandom().nextBytes(key);
        return key;
    }
}
```

## 步骤 8：创建 Agent TCP 客户端

**文件**: `src/main/java/cc/jfire/webcli/agent/AgentTcpClient.java`

```java
package cc.jfire.webcli.agent;

import cc.jfire.dson.Dson;
import cc.jfire.jnet.client.ClientChannel;
import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.common.api.ReadProcessor;
import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.common.coder.TotalLengthFieldBasedFrameDecoder;
import cc.jfire.jnet.common.processor.LengthEncoder;
import cc.jfire.jnet.common.util.ChannelConfig;
import cc.jfire.webcli.config.WebCliConfig;
import cc.jfire.webcli.crypto.AesGcmCrypto;
import cc.jfire.webcli.protocol.TcpMessage;
import cc.jfire.webcli.protocol.TcpMessageType;
import cc.jfire.webcli.pty.PtyInstance;
import cc.jfire.webcli.pty.PtyManager;
import lombok.extern.slf4j.Slf4j;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.KeyAgreement;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

@Slf4j
public class AgentTcpClient implements ReadProcessor<IoBuffer> {
    private final WebCliConfig config;
    private final PtyManager ptyManager;
    private final String agentId = UUID.randomUUID().toString();
    private final SecureRandom secureRandom = new SecureRandom();
    private ClientChannel clientChannel;
    private Pipeline pipeline;
    private AesGcmCrypto crypto;
    private volatile boolean authenticated = false;
    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    private final Map<String, Consumer<String>> ptyOutputListeners = new ConcurrentHashMap<>();
    private KeyPair clientKeyPair;
    private byte[] clientNonce;
    private String clientPubKey;
    private byte[] sessionKey;

    public AgentTcpClient(WebCliConfig config, PtyManager ptyManager) {
        this.config = config;
        this.ptyManager = ptyManager;
    }

    public void connect() {
        ChannelConfig channelConfig = new ChannelConfig()
                .setIp(config.getServerHost())
                .setPort(config.getServerPort());

        clientChannel = ClientChannel.newClient(channelConfig, pipeline -> {
            pipeline.addReadProcessor(new TotalLengthFieldBasedFrameDecoder(0, 4, 4, 1024 * 1024));
            pipeline.addReadProcessor(AgentTcpClient.this);
            pipeline.addWriteProcessor(new LengthEncoder(0, 4));
        });

        if (clientChannel.connect()) {
            this.pipeline = clientChannel.pipeline();
            log.info("已连接到远端服务器: {}:{}", config.getServerHost(), config.getServerPort());
            sendAuthRequest();
            startHeartbeat();
        } else {
            log.error("连接远端服务器失败: {}:{}", config.getServerHost(), config.getServerPort());
            scheduleReconnect();
        }
    }

    private void sendAuthRequest() {
        try {
            clientKeyPair = KeyPairGenerator.getInstance("X25519").generateKeyPair();
            clientPubKey = Base64.getEncoder().encodeToString(clientKeyPair.getPublic().getEncoded());

            clientNonce = new byte[32];
            secureRandom.nextBytes(clientNonce);
            String clientNonceB64 = Base64.getEncoder().encodeToString(clientNonce);

            String macInput = String.join("|", "AUTH_REQUEST", agentId, clientPubKey, clientNonceB64);
            String clientMac = Base64.getEncoder().encodeToString(hmacSha256(tokenBytes(), macInput.getBytes(StandardCharsets.UTF_8)));

            TcpMessage msg = new TcpMessage();
            msg.setType(TcpMessageType.AUTH_REQUEST);
            msg.setAgentId(agentId);
            msg.setClientNonce(clientNonceB64);
            msg.setClientPubKey(clientPubKey);
            msg.setClientMac(clientMac);
            sendMessage(msg, false); // 握手阶段明文
        } catch (Exception e) {
            log.error("发送认证请求失败", e);
        }
    }

    private void startHeartbeat() {
        scheduler.scheduleAtFixedRate(() -> {
            if (authenticated && clientChannel != null && clientChannel.alive()) {
                TcpMessage msg = new TcpMessage();
                msg.setType(TcpMessageType.HEARTBEAT);
                sendMessage(msg, true);
            }
        }, 30, 30, TimeUnit.SECONDS);
    }

    private void scheduleReconnect() {
        scheduler.schedule(() -> {
            log.info("尝试重新连接...");
            connect();
        }, 5, TimeUnit.SECONDS);
    }

    @Override
    public void read(IoBuffer buffer, ReadProcessorNode next) {
        try {
            byte[] data = new byte[buffer.remainRead()];
            buffer.get(data);

            byte[] decrypted;
            if (authenticated && crypto != null) {
                decrypted = crypto.decrypt(data);
            } else {
                decrypted = data;
            }

            String json = new String(decrypted, StandardCharsets.UTF_8);
            TcpMessage msg = Dson.fromString(TcpMessage.class, json);
            handleMessage(msg);
        } catch (Exception e) {
            log.error("处理消息失败", e);
        } finally {
            buffer.free();
        }
    }

    private void handleMessage(TcpMessage msg) {
        switch (msg.getType()) {
            case AUTH_RESPONSE -> handleAuthResponse(msg);
            case PTY_LIST_REQUEST -> handlePtyListRequest();
            case PTY_INPUT -> handlePtyInput(msg);
            case PTY_RESIZE -> handlePtyResize(msg);
            case PTY_CLOSE -> handlePtyClose(msg);
            case PTY_ATTACH -> handlePtyAttach(msg);
            case PTY_DETACH -> handlePtyDetach(msg);
            case HEARTBEAT -> {} // 忽略心跳响应
            default -> log.warn("未知消息类型: {}", msg.getType());
        }
    }

    private void handleAuthResponse(TcpMessage msg) {
        try {
            String serverPubKey = msg.getServerPubKey();
            String serverNonceB64 = msg.getServerNonce();
            String serverMac = msg.getServerMac();

            if (serverPubKey == null || serverNonceB64 == null || serverMac == null) {
                log.error("认证响应缺少必要字段");
                return;
            }

            // 校验 serverMac：HMAC(token, "AUTH_RESPONSE"||agentId||serverPubKey||serverNonce||clientPubKey||clientNonce)
            String clientNonceB64 = Base64.getEncoder().encodeToString(clientNonce);
            String macInput = String.join("|", "AUTH_RESPONSE", agentId, serverPubKey, serverNonceB64, clientPubKey, clientNonceB64);
            String expectedServerMac = Base64.getEncoder().encodeToString(hmacSha256(tokenBytes(), macInput.getBytes(StandardCharsets.UTF_8)));
            if (!expectedServerMac.equals(serverMac)) {
                log.error("认证失败：serverMac 校验不通过");
                return;
            }

            byte[] serverNonce = Base64.getDecoder().decode(serverNonceB64);
            PublicKey serverPublicKey = decodeX25519PublicKey(serverPubKey);
            byte[] sharedSecret = computeSharedSecret(clientKeyPair.getPrivate(), serverPublicKey);

            // 派生会话密钥：HMAC(token, sharedSecret || clientNonce || serverNonce)
            sessionKey = hmacSha256(tokenBytes(), concat(sharedSecret, clientNonce, serverNonce));
            crypto = new AesGcmCrypto(sessionKey);

            // 回发 AUTH_FINISH（基于 sessionKey 的 MAC），Server 校验成功后才正式注册 Agent
            String finishInput = String.join("|", "AUTH_FINISH", agentId);
            String finishMac = Base64.getEncoder().encodeToString(hmacSha256(sessionKey, finishInput.getBytes(StandardCharsets.UTF_8)));
            TcpMessage finish = new TcpMessage();
            finish.setType(TcpMessageType.AUTH_FINISH);
            finish.setAgentId(agentId);
            finish.setFinishMac(finishMac);
            sendMessage(finish, false); // AUTH_FINISH 明文

            authenticated = true;
            log.info("认证成功，会话密钥已建立");
        } catch (Exception e) {
            log.error("处理认证响应失败", e);
        }
    }

    private void handlePtyListRequest() {
        List<PtyInstance> remoteViewablePtys = ptyManager.getAll().stream()
                .filter(PtyInstance::isRemoteViewable)
                .toList();

        TcpMessage response = new TcpMessage();
        response.setType(TcpMessageType.PTY_LIST_RESPONSE);
        response.setAgentId(agentId);
        response.setData(Dson.toJson(remoteViewablePtys.stream()
                .map(pty -> new cc.jfire.webcli.protocol.PtyInfo(
                        pty.getId(), pty.getName(), pty.isAlive(), pty.isRemoteViewable()))
                .toList()));
        sendMessage(response, true);
    }

    private void handlePtyInput(TcpMessage msg) {
        PtyInstance pty = ptyManager.get(msg.getPtyId());
        if (pty != null && pty.isRemoteViewable()) {
            try {
                String decoded = new String(Base64.getDecoder().decode(msg.getData()), StandardCharsets.UTF_8);
                pty.write(decoded);
            } catch (Exception e) {
                log.error("写入 PTY 失败", e);
            }
        }
    }

    private void handlePtyResize(TcpMessage msg) {
        PtyInstance pty = ptyManager.get(msg.getPtyId());
        if (pty != null && pty.isRemoteViewable() && msg.getCols() != null && msg.getRows() != null) {
            pty.resize(msg.getCols(), msg.getRows());
        }
    }

    private void handlePtyClose(TcpMessage msg) {
        PtyInstance pty = ptyManager.get(msg.getPtyId());
        if (pty != null && pty.isRemoteViewable()) {
            ptyManager.remove(msg.getPtyId());
        }
    }

    private void handlePtyAttach(TcpMessage msg) {
        PtyInstance pty = ptyManager.get(msg.getPtyId());
        if (pty != null && pty.isRemoteViewable()) {
            // 创建输出监听器，将输出转发到远端
            Consumer<String> listener = output -> {
                TcpMessage outMsg = new TcpMessage();
                outMsg.setType(TcpMessageType.PTY_OUTPUT);
                outMsg.setPtyId(pty.getId());
                outMsg.setAgentId(agentId);
                outMsg.setData(Base64.getEncoder().encodeToString(output.getBytes(StandardCharsets.UTF_8)));
                sendMessage(outMsg, true);
            };

            // 保存监听器引用以便后续移除
            ptyOutputListeners.put(msg.getPtyId(), listener);
            // 注册到 PtyInstance
            pty.addOutputListener(listener);

            // 发送历史输出
            String history = pty.getOutputHistory();
            if (history != null && !history.isEmpty()) {
                TcpMessage historyMsg = new TcpMessage();
                historyMsg.setType(TcpMessageType.PTY_OUTPUT);
                historyMsg.setPtyId(pty.getId());
                historyMsg.setAgentId(agentId);
                historyMsg.setData(Base64.getEncoder().encodeToString(history.getBytes(StandardCharsets.UTF_8)));
                sendMessage(historyMsg, true);
            }
        }
    }

    private void handlePtyDetach(TcpMessage msg) {
        Consumer<String> listener = ptyOutputListeners.remove(msg.getPtyId());
        if (listener != null) {
            PtyInstance pty = ptyManager.get(msg.getPtyId());
            if (pty != null) {
                pty.removeOutputListener(listener);
            }
        }
    }

    private void sendMessage(TcpMessage msg, boolean encrypt) {
        if (pipeline == null) return;

        try {
            String json = Dson.toJson(msg);
            byte[] data = json.getBytes(StandardCharsets.UTF_8);

            if (encrypt && crypto != null) {
                data = crypto.encrypt(data);
            }

            // 预留 4 字节 TotalLen，由 LengthEncoder(0,4) 回填整个帧长度
            IoBuffer buffer = pipeline.allocator().allocate(data.length + 4);
            buffer.putInt(0);
            buffer.put(data);
            pipeline.fireWrite(buffer);
        } catch (Exception e) {
            log.error("发送消息失败", e);
        }
    }

    private byte[] tokenBytes() {
        return config.getToken().getBytes(StandardCharsets.UTF_8);
    }

    private static byte[] hmacSha256(byte[] key, byte[] data) throws Exception {
        Mac mac = Mac.getInstance("HmacSHA256");
        mac.init(new SecretKeySpec(key, "HmacSHA256"));
        return mac.doFinal(data);
    }

    private static byte[] concat(byte[]... parts) {
        int total = 0;
        for (byte[] part : parts) {
            total += part.length;
        }
        byte[] out = new byte[total];
        int offset = 0;
        for (byte[] part : parts) {
            System.arraycopy(part, 0, out, offset, part.length);
            offset += part.length;
        }
        return out;
    }

    private static PublicKey decodeX25519PublicKey(String base64) throws Exception {
        byte[] encoded = Base64.getDecoder().decode(base64);
        KeyFactory keyFactory = KeyFactory.getInstance("X25519");
        return keyFactory.generatePublic(new X509EncodedKeySpec(encoded));
    }

    private static byte[] computeSharedSecret(PrivateKey privateKey, PublicKey publicKey) throws Exception {
        KeyAgreement agreement = KeyAgreement.getInstance("X25519");
        agreement.init(privateKey);
        agreement.doPhase(publicKey, true);
        return agreement.generateSecret();
    }

    @Override
    public void readFailed(Throwable e, ReadProcessorNode next) {
        log.error("连接断开", e);
        authenticated = false;
        scheduleReconnect();
    }

    public void shutdown() {
        scheduler.shutdown();
        if (clientChannel != null && pipeline != null) {
            pipeline.shutdownInput();
        }
    }
}
```

## 步骤 9：创建远端 WebServer TCP 服务端

**文件**: `src/main/java/cc/jfire/webcli/server/ServerTcpHandler.java`

```java
package cc.jfire.webcli.server;

import cc.jfire.dson.Dson;
import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.common.api.ReadProcessor;
import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.webcli.config.WebCliConfig;
import cc.jfire.webcli.crypto.AesGcmCrypto;
import cc.jfire.webcli.protocol.TcpMessage;
import cc.jfire.webcli.protocol.TcpMessageType;
import lombok.extern.slf4j.Slf4j;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.KeyAgreement;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

@Slf4j
public class ServerTcpHandler implements ReadProcessor<IoBuffer> {
    private final WebCliConfig config;
    private final AgentManager agentManager;
    private final SecureRandom secureRandom = new SecureRandom();
    private Pipeline pipeline;
    private AesGcmCrypto crypto;
    private volatile boolean authenticated = false;
    private String agentId;
    private KeyPair serverKeyPair;
    private byte[] clientNonce;
    private String clientPubKey;
    private byte[] serverNonce;
    private byte[] sessionKey;

    public ServerTcpHandler(WebCliConfig config, AgentManager agentManager) {
        this.config = config;
        this.agentManager = agentManager;
    }

    @Override
    public void read(IoBuffer buffer, ReadProcessorNode next) {
        this.pipeline = next.pipeline();
        try {
            byte[] data = new byte[buffer.remainRead()];
            buffer.get(data);

            byte[] decrypted;
            if (authenticated && crypto != null) {
                decrypted = crypto.decrypt(data);
            } else {
                decrypted = data;
            }

            String json = new String(decrypted, StandardCharsets.UTF_8);
            TcpMessage msg = Dson.fromString(TcpMessage.class, json);
            handleMessage(msg);
        } catch (Exception e) {
            log.error("处理消息失败", e);
        } finally {
            buffer.free();
        }
    }

    private void handleMessage(TcpMessage msg) {
        switch (msg.getType()) {
            case AUTH_REQUEST -> handleAuthRequest(msg);
            case AUTH_FINISH -> handleAuthFinish(msg);
            case PTY_LIST_RESPONSE -> handlePtyListResponse(msg);
            case PTY_OUTPUT -> handlePtyOutput(msg);
            case HEARTBEAT -> sendHeartbeatResponse();
            default -> log.warn("未知消息类型: {}", msg.getType());
        }
    }

    private void handleAuthRequest(TcpMessage msg) {
        try {
            String agentId = msg.getAgentId();
            String clientNonceB64 = msg.getClientNonce();
            String clientPubKey = msg.getClientPubKey();
            String clientMac = msg.getClientMac();

            if (agentId == null || clientNonceB64 == null || clientPubKey == null || clientMac == null) {
                log.warn("AUTH_REQUEST 缺少必要字段");
                return;
            }

            // 校验 clientMac：HMAC(token, "AUTH_REQUEST"||agentId||clientPubKey||clientNonce)
            String macInput = String.join("|", "AUTH_REQUEST", agentId, clientPubKey, clientNonceB64);
            String expectedClientMac = Base64.getEncoder().encodeToString(hmacSha256(tokenBytes(), macInput.getBytes(StandardCharsets.UTF_8)));
            if (!expectedClientMac.equals(clientMac)) {
                log.warn("Agent 认证失败：clientMac 校验不通过");
                TcpMessage response = new TcpMessage();
                response.setType(TcpMessageType.AUTH_RESPONSE);
                response.setData("INVALID_AUTH");
                sendMessage(response, false);
                return;
            }

            this.agentId = agentId;
            this.clientPubKey = clientPubKey;
            this.clientNonce = Base64.getDecoder().decode(clientNonceB64);

            // 生成服务端握手参数
            serverKeyPair = KeyPairGenerator.getInstance("X25519").generateKeyPair();
            String serverPubKey = Base64.getEncoder().encodeToString(serverKeyPair.getPublic().getEncoded());
            serverNonce = new byte[32];
            secureRandom.nextBytes(serverNonce);
            String serverNonceB64 = Base64.getEncoder().encodeToString(serverNonce);

            // 计算 serverMac：HMAC(token, "AUTH_RESPONSE"||agentId||serverPubKey||serverNonce||clientPubKey||clientNonce)
            String serverMacInput = String.join("|", "AUTH_RESPONSE", agentId, serverPubKey, serverNonceB64, clientPubKey, clientNonceB64);
            String serverMac = Base64.getEncoder().encodeToString(hmacSha256(tokenBytes(), serverMacInput.getBytes(StandardCharsets.UTF_8)));

            // 派生会话密钥（等 AUTH_FINISH 校验通过后再标记 authenticated）
            PublicKey clientPublicKey = decodeX25519PublicKey(clientPubKey);
            byte[] sharedSecret = computeSharedSecret(serverKeyPair.getPrivate(), clientPublicKey);
            sessionKey = hmacSha256(tokenBytes(), concat(sharedSecret, this.clientNonce, serverNonce));

            TcpMessage response = new TcpMessage();
            response.setType(TcpMessageType.AUTH_RESPONSE);
            response.setAgentId(agentId);
            response.setServerPubKey(serverPubKey);
            response.setServerNonce(serverNonceB64);
            response.setServerMac(serverMac);
            sendMessage(response, false); // 握手阶段明文
        } catch (Exception e) {
            log.error("处理 AUTH_REQUEST 失败", e);
        }
    }

    private void handleAuthFinish(TcpMessage msg) {
        try {
            if (sessionKey == null || agentId == null) {
                log.warn("收到 AUTH_FINISH 但会话未初始化");
                return;
            }
            String finishMac = msg.getFinishMac();
            if (finishMac == null) {
                log.warn("AUTH_FINISH 缺少 finishMac");
                return;
            }
            String finishInput = String.join("|", "AUTH_FINISH", agentId);
            String expectedFinishMac = Base64.getEncoder().encodeToString(hmacSha256(sessionKey, finishInput.getBytes(StandardCharsets.UTF_8)));
            if (!expectedFinishMac.equals(finishMac)) {
                log.warn("Agent 认证失败：finishMac 校验不通过");
                return;
            }

            this.crypto = new AesGcmCrypto(sessionKey);
            this.authenticated = true;
            agentManager.registerAgent(agentId, this);
            log.info("Agent 认证成功: {}", agentId);
        } catch (Exception e) {
            log.error("处理 AUTH_FINISH 失败", e);
        }
    }

    private void handlePtyListResponse(TcpMessage msg) {
        agentManager.updatePtyList(agentId, msg.getData());
    }

    private void handlePtyOutput(TcpMessage msg) {
        agentManager.forwardPtyOutput(agentId, msg.getPtyId(), msg.getData());
    }

    private void sendHeartbeatResponse() {
        TcpMessage msg = new TcpMessage();
        msg.setType(TcpMessageType.HEARTBEAT);
        sendMessage(msg, true);
    }

    public void sendMessage(TcpMessage msg, boolean encrypt) {
        if (pipeline == null) return;

        try {
            String json = Dson.toJson(msg);
            byte[] data = json.getBytes(StandardCharsets.UTF_8);

            if (encrypt && crypto != null) {
                data = crypto.encrypt(data);
            }

            // 预留 4 字节 TotalLen，由 LengthEncoder(0,4) 回填整个帧长度
            IoBuffer buffer = pipeline.allocator().allocate(data.length + 4);
            buffer.putInt(0);
            buffer.put(data);
            pipeline.fireWrite(buffer);
        } catch (Exception e) {
            log.error("发送消息失败", e);
        }
    }

    private byte[] tokenBytes() {
        return config.getToken().getBytes(StandardCharsets.UTF_8);
    }

    private static byte[] hmacSha256(byte[] key, byte[] data) throws Exception {
        Mac mac = Mac.getInstance("HmacSHA256");
        mac.init(new SecretKeySpec(key, "HmacSHA256"));
        return mac.doFinal(data);
    }

    private static byte[] concat(byte[]... parts) {
        int total = 0;
        for (byte[] part : parts) {
            total += part.length;
        }
        byte[] out = new byte[total];
        int offset = 0;
        for (byte[] part : parts) {
            System.arraycopy(part, 0, out, offset, part.length);
            offset += part.length;
        }
        return out;
    }

    private static PublicKey decodeX25519PublicKey(String base64) throws Exception {
        byte[] encoded = Base64.getDecoder().decode(base64);
        KeyFactory keyFactory = KeyFactory.getInstance("X25519");
        return keyFactory.generatePublic(new X509EncodedKeySpec(encoded));
    }

    private static byte[] computeSharedSecret(PrivateKey privateKey, PublicKey publicKey) throws Exception {
        KeyAgreement agreement = KeyAgreement.getInstance("X25519");
        agreement.init(privateKey);
        agreement.doPhase(publicKey, true);
        return agreement.generateSecret();
    }

    public void requestPtyList() {
        TcpMessage msg = new TcpMessage();
        msg.setType(TcpMessageType.PTY_LIST_REQUEST);
        sendMessage(msg, true);
    }

    public void sendPtyInput(String ptyId, String data) {
        TcpMessage msg = new TcpMessage();
        msg.setType(TcpMessageType.PTY_INPUT);
        msg.setPtyId(ptyId);
        msg.setData(data);
        sendMessage(msg, true);
    }

    public void sendPtyResize(String ptyId, int cols, int rows) {
        TcpMessage msg = new TcpMessage();
        msg.setType(TcpMessageType.PTY_RESIZE);
        msg.setPtyId(ptyId);
        msg.setCols(cols);
        msg.setRows(rows);
        sendMessage(msg, true);
    }

    public void sendPtyClose(String ptyId) {
        TcpMessage msg = new TcpMessage();
        msg.setType(TcpMessageType.PTY_CLOSE);
        msg.setPtyId(ptyId);
        sendMessage(msg, true);
    }

    public void sendPtyAttach(String ptyId) {
        TcpMessage msg = new TcpMessage();
        msg.setType(TcpMessageType.PTY_ATTACH);
        msg.setPtyId(ptyId);
        sendMessage(msg, true);
    }

    public void sendPtyDetach(String ptyId) {
        TcpMessage msg = new TcpMessage();
        msg.setType(TcpMessageType.PTY_DETACH);
        msg.setPtyId(ptyId);
        sendMessage(msg, true);
    }

    @Override
    public void readFailed(Throwable e, ReadProcessorNode next) {
        log.error("Agent 连接断开: {}", agentId, e);
        if (agentId != null) {
            agentManager.unregisterAgent(agentId);
        }
    }

    public String getAgentId() {
        return agentId;
    }

    public boolean isAuthenticated() {
        return authenticated;
    }
}
```

## 步骤 10：创建 Agent 管理器

**文件**: `src/main/java/cc/jfire/webcli/server/AgentManager.java`

```java
package cc.jfire.webcli.server;

import cc.jfire.dson.Dson;
import cc.jfire.webcli.protocol.PtyInfo;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiConsumer;

@Slf4j
public class AgentManager {
    private final Map<String, ServerTcpHandler> agents = new ConcurrentHashMap<>();
    private final Map<String, List<PtyInfo>> agentPtyLists = new ConcurrentHashMap<>();
    private final Map<String, BiConsumer<String, String>> ptyOutputListeners = new ConcurrentHashMap<>();

    public void registerAgent(String agentId, ServerTcpHandler handler) {
        agents.put(agentId, handler);
        log.info("Agent 已注册: {}", agentId);
    }

    public void unregisterAgent(String agentId) {
        agents.remove(agentId);
        agentPtyLists.remove(agentId);
        log.info("Agent 已注销: {}", agentId);
    }

    public void updatePtyList(String agentId, String ptyListJson) {
        try {
            List<PtyInfo> list = Dson.fromStringToList(PtyInfo.class, ptyListJson);
            agentPtyLists.put(agentId, list);
        } catch (Exception e) {
            log.error("解析 PTY 列表失败", e);
        }
    }

    public List<PtyInfo> getAllRemotePtys() {
        List<PtyInfo> result = new ArrayList<>();
        for (Map.Entry<String, List<PtyInfo>> entry : agentPtyLists.entrySet()) {
            String agentId = entry.getKey();
            for (PtyInfo pty : entry.getValue()) {
                // 创建新的 PtyInfo，ID 前缀加上 agentId
                PtyInfo remotePty = new PtyInfo(
                        agentId + ":" + pty.getId(),
                        pty.getName(),
                        pty.isAlive(),
                        pty.isRemoteViewable()
                );
                result.add(remotePty);
            }
        }
        return result;
    }

    public void refreshAllPtyLists() {
        for (ServerTcpHandler handler : agents.values()) {
            if (handler.isAuthenticated()) {
                handler.requestPtyList();
            }
        }
    }

    public void forwardPtyOutput(String agentId, String ptyId, String data) {
        String fullPtyId = agentId + ":" + ptyId;
        BiConsumer<String, String> listener = ptyOutputListeners.get(fullPtyId);
        if (listener != null) {
            listener.accept(fullPtyId, data);
        }
    }

    public void registerPtyOutputListener(String fullPtyId, BiConsumer<String, String> listener) {
        ptyOutputListeners.put(fullPtyId, listener);
    }

    public void unregisterPtyOutputListener(String fullPtyId) {
        ptyOutputListeners.remove(fullPtyId);
    }

    public ServerTcpHandler getAgentHandler(String agentId) {
        return agents.get(agentId);
    }

    public String[] parseFullPtyId(String fullPtyId) {
        int idx = fullPtyId.indexOf(':');
        if (idx > 0) {
            return new String[]{fullPtyId.substring(0, idx), fullPtyId.substring(idx + 1)};
        }
        return null;
    }
}
```

## 步骤 11：创建远端 WebSocket 处理器

**文件**: `src/main/java/cc/jfire/webcli/server/RemoteWebSocketHandler.java`

```java
package cc.jfire.webcli.server;

import cc.jfire.dson.Dson;
import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.common.api.ReadProcessor;
import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.common.buffer.buffer.IoBuffer;
import cc.jfire.jnet.extend.websocket.dto.WebSocketFrame;
import cc.jfire.webcli.protocol.MessageType;
import cc.jfire.webcli.protocol.PtyInfo;
import cc.jfire.webcli.protocol.WsMessage;
import lombok.extern.slf4j.Slf4j;

import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
public class RemoteWebSocketHandler implements ReadProcessor<Object> {
    private final AgentManager agentManager;
    private final ConcurrentHashMap<String, String> pipelinePtyMap = new ConcurrentHashMap<>();

    public RemoteWebSocketHandler(AgentManager agentManager) {
        this.agentManager = agentManager;
    }

    @Override
    public void read(Object obj, ReadProcessorNode next) {
        if (obj instanceof WebSocketFrame frame) {
            Pipeline pipeline = next.pipeline();
            try {
                if (frame.getOpcode() == WebSocketFrame.OPCODE_CLOSE) {
                    handleClose(pipeline);
                    return;
                }
                if (frame.getOpcode() == WebSocketFrame.OPCODE_TEXT) {
                    IoBuffer payload = frame.getPayload();
                    byte[] bytes = new byte[payload.remainRead()];
                    payload.get(bytes);
                    String text = new String(bytes, StandardCharsets.UTF_8);
                    handleMessage(pipeline, text);
                }
            } finally {
                frame.free();
            }
        } else {
            next.fireRead(obj);
        }
    }

    private void handleMessage(Pipeline pipeline, String text) {
        try {
            WsMessage msg = Dson.fromString(WsMessage.class, text);
            switch (msg.getType()) {
                case PTY_REMOTE_LIST -> handlePtyRemoteList(pipeline);
                case PTY_INPUT -> handlePtyInput(pipeline, msg);
                case PTY_RESIZE -> handlePtyResize(pipeline, msg);
                case PTY_CLOSE -> handlePtyClose(pipeline, msg);
                case PTY_ATTACH -> handlePtyAttach(pipeline, msg);
                default -> log.warn("远端 Web 不支持的消息类型: {}", msg.getType());
            }
        } catch (Exception e) {
            log.error("处理消息失败", e);
            sendError(pipeline, e.getMessage());
        }
    }

    private void handlePtyRemoteList(Pipeline pipeline) {
        // 刷新所有 Agent 的 PTY 列表
        agentManager.refreshAllPtyLists();

        // 等待短暂时间让 Agent 响应
        try { Thread.sleep(100); } catch (InterruptedException ignored) {}

        List<PtyInfo> list = agentManager.getAllRemotePtys();
        WsMessage response = new WsMessage();
        response.setType(MessageType.PTY_REMOTE_LIST);
        response.setData(Dson.toJson(list));
        sendMessage(pipeline, response);
    }

    private void handlePtyInput(Pipeline pipeline, WsMessage msg) {
        String fullPtyId = msg.getPtyId();
        String[] parts = agentManager.parseFullPtyId(fullPtyId);
        if (parts != null) {
            ServerTcpHandler handler = agentManager.getAgentHandler(parts[0]);
            if (handler != null) {
                handler.sendPtyInput(parts[1], msg.getData());
            }
        }
    }

    private void handlePtyResize(Pipeline pipeline, WsMessage msg) {
        String fullPtyId = msg.getPtyId();
        String[] parts = agentManager.parseFullPtyId(fullPtyId);
        if (parts != null && msg.getCols() != null && msg.getRows() != null) {
            ServerTcpHandler handler = agentManager.getAgentHandler(parts[0]);
            if (handler != null) {
                handler.sendPtyResize(parts[1], msg.getCols(), msg.getRows());
            }
        }
    }

    private void handlePtyClose(Pipeline pipeline, WsMessage msg) {
        String fullPtyId = msg.getPtyId();
        String[] parts = agentManager.parseFullPtyId(fullPtyId);
        if (parts != null) {
            ServerTcpHandler handler = agentManager.getAgentHandler(parts[0]);
            if (handler != null) {
                handler.sendPtyClose(parts[1]);
            }
            agentManager.unregisterPtyOutputListener(fullPtyId);
            pipelinePtyMap.remove(pipeline.pipelineId());
        }

        WsMessage response = new WsMessage();
        response.setType(MessageType.SUCCESS);
        sendMessage(pipeline, response);
    }

    private void handlePtyAttach(Pipeline pipeline, WsMessage msg) {
        String fullPtyId = msg.getPtyId();
        String[] parts = agentManager.parseFullPtyId(fullPtyId);
        if (parts != null) {
            ServerTcpHandler handler = agentManager.getAgentHandler(parts[0]);
            if (handler != null) {
                pipelinePtyMap.put(pipeline.pipelineId(), fullPtyId);

                // 注册输出监听器
                agentManager.registerPtyOutputListener(fullPtyId, (ptyId, data) -> {
                    WsMessage outMsg = new WsMessage();
                    outMsg.setType(MessageType.PTY_OUTPUT);
                    outMsg.setPtyId(ptyId);
                    outMsg.setData(data);
                    sendMessage(pipeline, outMsg);
                });

                // 通知 Agent 附加到该终端
                handler.sendPtyAttach(parts[1]);

                WsMessage response = new WsMessage();
                response.setType(MessageType.SUCCESS);
                response.setPtyId(fullPtyId);
                sendMessage(pipeline, response);
            } else {
                sendError(pipeline, "Agent 不存在");
            }
        } else {
            sendError(pipeline, "无效的 PTY ID");
        }
    }

    private void handleClose(Pipeline pipeline) {
        String fullPtyId = pipelinePtyMap.remove(pipeline.pipelineId());
        if (fullPtyId != null) {
            agentManager.unregisterPtyOutputListener(fullPtyId);
            String[] parts = agentManager.parseFullPtyId(fullPtyId);
            if (parts != null) {
                ServerTcpHandler handler = agentManager.getAgentHandler(parts[0]);
                if (handler != null) {
                    handler.sendPtyDetach(parts[1]);
                }
            }
        }
    }

    private void sendMessage(Pipeline pipeline, WsMessage msg) {
        String json = Dson.toJson(msg);
        byte[] bytes = json.getBytes(StandardCharsets.UTF_8);
        IoBuffer payload = pipeline.allocator().allocate(bytes.length);
        payload.put(bytes);
        WebSocketFrame frame = new WebSocketFrame();
        frame.setOpcode(WebSocketFrame.OPCODE_TEXT);
        frame.setPayload(payload);
        pipeline.fireWrite(frame);
    }

    private void sendError(Pipeline pipeline, String error) {
        WsMessage msg = new WsMessage();
        msg.setType(MessageType.ERROR);
        msg.setData(error);
        sendMessage(pipeline, msg);
    }

    @Override
    public void readFailed(Throwable e, ReadProcessorNode next) {
        log.error("WebSocket 读取失败", e);
        handleClose(next.pipeline());
    }
}
```

## 步骤 12：扩展 WebSocketHandler 处理远程可见设置和多输出监听器

**文件**: `src/main/java/cc/jfire/webcli/web/WebSocketHandler.java`

添加新的成员变量用于保存监听器引用：

```java
private final ConcurrentHashMap<String, Consumer<String>> pipelineOutputListeners = new ConcurrentHashMap<>();
```

在 `handleMessage` 方法的 switch 语句中添加：

```java
case PTY_SET_REMOTE_VIEWABLE -> handleSetRemoteViewable(pipeline, msg);
```

修改 `handlePtyCreate` 方法，使用 `addOutputListener`：

```java
private void handlePtyCreate(Pipeline pipeline, WsMessage msg) throws IOException {
    String name = msg.getName();
    PtyInstance pty = ptyManager.create(name);
    pipelinePtyMap.put(pipeline.pipelineId(), pty.getId());

    // 创建输出监听器
    Consumer<String> listener = output -> {
        WsMessage outMsg = new WsMessage();
        outMsg.setType(MessageType.PTY_OUTPUT);
        outMsg.setPtyId(pty.getId());
        outMsg.setData(Base64.getEncoder().encodeToString(output.getBytes(StandardCharsets.UTF_8)));
        sendMessage(pipeline, outMsg);
    };
    // 保存监听器引用
    pipelineOutputListeners.put(pipeline.pipelineId(), listener);
    // 注册到 PtyInstance
    pty.addOutputListener(listener);

    pty.startReading();
    WsMessage response = new WsMessage();
    response.setType(MessageType.SUCCESS);
    response.setPtyId(pty.getId());
    response.setName(pty.getName());
    sendMessage(pipeline, response);
}
```

修改 `handlePtyAttach` 方法，使用 `addOutputListener`：

```java
private void handlePtyAttach(Pipeline pipeline, WsMessage msg) {
    PtyInstance pty = ptyManager.get(msg.getPtyId());
    if (pty != null) {
        // 绑定当前连接到该 PTY
        pipelinePtyMap.put(pipeline.pipelineId(), msg.getPtyId());

        // 移除旧的监听器（如果有）
        Consumer<String> oldListener = pipelineOutputListeners.remove(pipeline.pipelineId());
        if (oldListener != null) {
            // 从之前的 PTY 移除监听器
            for (PtyInstance p : ptyManager.getAll()) {
                p.removeOutputListener(oldListener);
            }
        }

        // 创建新的输出监听器
        Consumer<String> listener = output -> {
            WsMessage outMsg = new WsMessage();
            outMsg.setType(MessageType.PTY_OUTPUT);
            outMsg.setPtyId(pty.getId());
            outMsg.setData(Base64.getEncoder().encodeToString(output.getBytes(StandardCharsets.UTF_8)));
            sendMessage(pipeline, outMsg);
        };
        // 保存监听器引用
        pipelineOutputListeners.put(pipeline.pipelineId(), listener);
        // 注册到 PtyInstance
        pty.addOutputListener(listener);

        // 发送历史输出
        String history = pty.getOutputHistory();
        if (history != null && !history.isEmpty()) {
            WsMessage historyMsg = new WsMessage();
            historyMsg.setType(MessageType.PTY_OUTPUT);
            historyMsg.setPtyId(pty.getId());
            historyMsg.setData(Base64.getEncoder().encodeToString(history.getBytes(StandardCharsets.UTF_8)));
            sendMessage(pipeline, historyMsg);
        }
        // 发送成功响应
        WsMessage response = new WsMessage();
        response.setType(MessageType.SUCCESS);
        response.setPtyId(msg.getPtyId());
        sendMessage(pipeline, response);
    } else {
        sendError(pipeline, "PTY 不存在: " + msg.getPtyId());
    }
}
```

修改 `handleClose` 方法，移除监听器：

```java
private void handleClose(Pipeline pipeline) {
    String ptyId = pipelinePtyMap.remove(pipeline.pipelineId());
    Consumer<String> listener = pipelineOutputListeners.remove(pipeline.pipelineId());
    if (listener != null && ptyId != null) {
        PtyInstance pty = ptyManager.get(ptyId);
        if (pty != null) {
            pty.removeOutputListener(listener);
        }
    }
}
```

添加新方法 `handleSetRemoteViewable`：

```java
private void handleSetRemoteViewable(Pipeline pipeline, WsMessage msg) {
    PtyInstance pty = ptyManager.get(msg.getPtyId());
    if (pty != null) {
        pty.setRemoteViewable(msg.getRemoteViewable() != null && msg.getRemoteViewable());
        WsMessage response = new WsMessage();
        response.setType(MessageType.SUCCESS);
        response.setPtyId(msg.getPtyId());
        response.setRemoteViewable(pty.isRemoteViewable());
        sendMessage(pipeline, response);
        log.info("设置终端 {} 远程可见: {}", msg.getPtyId(), pty.isRemoteViewable());
    } else {
        sendError(pipeline, "PTY 不存在: " + msg.getPtyId());
    }
}
```

修改 `handlePtyList` 方法，返回 `remoteViewable` 属性：

```java
private void handlePtyList(Pipeline pipeline) {
    List<PtyInfo> list = ptyManager.getAll().stream()
            .map(pty -> new PtyInfo(pty.getId(), pty.getName(), pty.isAlive(), pty.isRemoteViewable()))
            .toList();
    WsMessage response = new WsMessage();
    response.setType(MessageType.PTY_LIST);
    response.setData(Dson.toJson(list));
    sendMessage(pipeline, response);
}
```

## 步骤 13：修改 WebApplication 支持双模式启动

**文件**: `src/main/java/cc/jfire/webcli/WebApplication.java`

```java
package cc.jfire.webcli;

import cc.jfire.baseutil.RuntimeJVM;
import cc.jfire.boot.http.HttpAppServer;
import cc.jfire.dson.Dson;
import cc.jfire.jfire.core.ApplicationContext;
import cc.jfire.jfire.core.prepare.annotation.EnableAutoConfiguration;
import cc.jfire.jfire.core.prepare.annotation.configuration.Configuration;
import cc.jfire.jnet.common.coder.TotalLengthFieldBasedFrameDecoder;
import cc.jfire.jnet.common.processor.LengthEncoder;
import cc.jfire.jnet.common.util.ChannelConfig;
import cc.jfire.jnet.server.AioServer;
import cc.jfire.webcli.agent.AgentTcpClient;
import cc.jfire.webcli.config.WebCliConfig;
import cc.jfire.webcli.pty.PtyManager;
import cc.jfire.webcli.server.AgentManager;
import cc.jfire.webcli.server.RemoteWebSocketHandler;
import cc.jfire.webcli.server.ServerTcpHandler;
import cc.jfire.webcli.web.WebSocketHandler;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

@Slf4j
@EnableAutoConfiguration
@Configuration
public class WebApplication {
    private static final String CONFIG_FILE = "webcli.json";
    private final WebCliConfig config;
    private AioServer webServer;
    private AioServer tcpServer;
    private PtyManager ptyManager;
    private AgentTcpClient agentTcpClient;
    private AgentManager agentManager;

    public WebApplication(WebCliConfig config) {
        this.config = config;
    }

    public void start() {
        if (config.isServerMode()) {
            startServerMode();
        } else {
            startAgentMode();
        }
    }

    private void startAgentMode() {
        // 启动本地 PTY 管理器和 Web 服务
        this.ptyManager = new PtyManager(config);
        WebSocketHandler wsHandler = new WebSocketHandler(ptyManager);
        ApplicationContext context = ApplicationContext.boot(WebApplication.class);

        ChannelConfig channelConfig = new ChannelConfig()
                .setIp("127.0.0.1")
                .setPort(config.getWebPort())
                .setChannelGroup(ChannelConfig.DEFAULT_CHANNEL_GROUP);
        HttpAppServer.StartParam startParam = new HttpAppServer.StartParam()
                .setChannelConfig(channelConfig)
                .setContext(context)
                .setWebDir("local")
                .setWebSocketProcessor(wsHandler);
        webServer = HttpAppServer.start(startParam);
        log.info("本地 Web 服务已启动，监听地址: {}:{}", channelConfig.getIp(), config.getWebPort());
        log.info("请访问: http://127.0.0.1:{}/", config.getWebPort());

        // 如果配置了远端服务器，启动 TCP 客户端
        if (config.getServerHost() != null && !config.getServerHost().isBlank()) {
            agentTcpClient = new AgentTcpClient(config, ptyManager);
            agentTcpClient.connect();
            log.info("正在连接远端服务器: {}:{}", config.getServerHost(), config.getServerPort());
        }
    }

    private void startServerMode() {
        // 启动 Agent 管理器
        this.agentManager = new AgentManager();

        // 启动 TCP 服务端，接受 Agent 连接
        ChannelConfig tcpConfig = new ChannelConfig()
                .setIp("0.0.0.0")
                .setPort(config.getTcpPort())
                .setChannelGroup(ChannelConfig.DEFAULT_CHANNEL_GROUP);
        tcpServer = AioServer.newAioServer(tcpConfig, pipeline -> {
            pipeline.addReadProcessor(new TotalLengthFieldBasedFrameDecoder(0, 4, 4, 1024 * 1024));
            pipeline.addReadProcessor(new ServerTcpHandler(config, agentManager));
            pipeline.addWriteProcessor(new LengthEncoder(0, 4));
        });
        tcpServer.start();
        log.info("TCP 服务已启动，监听端口: {}", config.getTcpPort());

        // 启动远端 Web 服务
        RemoteWebSocketHandler wsHandler = new RemoteWebSocketHandler(agentManager);
        ApplicationContext context = ApplicationContext.boot(WebApplication.class);

        ChannelConfig webConfig = new ChannelConfig()
                .setIp("0.0.0.0")
                .setPort(config.getWebPort())
                .setChannelGroup(ChannelConfig.DEFAULT_CHANNEL_GROUP);
        HttpAppServer.StartParam startParam = new HttpAppServer.StartParam()
                .setChannelConfig(webConfig)
                .setContext(context)
                .setWebDir("remote")
                .setWebSocketProcessor(wsHandler);
        webServer = HttpAppServer.start(startParam);
        log.info("远端 Web 服务已启动，监听端口: {}", config.getWebPort());
    }

    public void shutdown() {
        if (webServer != null) {
            webServer.shutdown();
        }
        if (tcpServer != null) {
            tcpServer.shutdown();
        }
        if (ptyManager != null) {
            ptyManager.shutdown();
        }
        if (agentTcpClient != null) {
            agentTcpClient.shutdown();
        }
        log.info("WebCli 服务已关闭");
    }

    public static void main(String[] args) {
        RuntimeJVM.registerMainClass(WebApplication.class.getName());
        WebCliConfig config = loadConfig();
        WebApplication app = new WebApplication(config);
        Runtime.getRuntime().addShutdownHook(new Thread(app::shutdown));
        app.start();
    }

    private static WebCliConfig loadConfig() {
        Path configPath = Path.of(CONFIG_FILE);
        if (Files.exists(configPath)) {
            try {
                String json = Files.readString(configPath);
                WebCliConfig config = Dson.fromString(WebCliConfig.class, json);
                log.info("已加载配置文件: {}", CONFIG_FILE);
                return config;
            } catch (IOException e) {
                log.warn("读取配置文件失败，使用默认配置", e);
            }
        }
        return WebCliConfig.defaultConfig();
    }
}
```

## 步骤 14：更新本地前端界面

**文件**: `src/main/resources/local/index.html`

目录调整说明：
- 将本地静态资源目录统一为 `local/`（对应 `WebApplication` 的 `.setWebDir("local")`）。
- 将 xterm 相关资源复制一份到 `src/main/resources/local/lib/`（不与远端复用同一份资源）。

在 `context-menu` div 中添加新菜单项：

```html
<div class="context-menu-item" id="menu-remote-view">设置可远程查看</div>
```

在 JavaScript 中添加处理逻辑：

```javascript
// 在 MessageType 对象中添加
PTY_SET_REMOTE_VIEWABLE: 'PTY_SET_REMOTE_VIEWABLE',

// 在 WebCliTerminal 类中添加属性
this.terminalRemoteViewable = new Map();

// 在 initContextMenu 方法中添加
document.getElementById('menu-remote-view').addEventListener('click', (e) => {
    e.stopPropagation();
    const ptyId = this.contextMenuPtyId;
    this.hideContextMenu();
    if (ptyId) {
        this.toggleRemoteViewable(ptyId);
    }
});

// 添加新方法
toggleRemoteViewable(ptyId) {
    const currentState = this.terminalRemoteViewable.get(ptyId) || false;
    this.send({
        type: MessageType.PTY_SET_REMOTE_VIEWABLE,
        ptyId,
        remoteViewable: !currentState
    });
}

// 修改 showContextMenu 方法，更新菜单项文本
showContextMenu(e, ptyId) {
    e.preventDefault();
    this.contextMenuPtyId = ptyId;
    const menu = document.getElementById('context-menu');
    const remoteViewItem = document.getElementById('menu-remote-view');
    const isRemoteViewable = this.terminalRemoteViewable.get(ptyId) || false;
    remoteViewItem.textContent = isRemoteViewable ? '取消远程查看' : '设置可远程查看';
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    menu.classList.add('show');
}

// 在 handleMessage 的 SUCCESS 分支中处理 remoteViewable 响应
if (msg.remoteViewable !== undefined) {
    this.terminalRemoteViewable.set(msg.ptyId, msg.remoteViewable);
    this.updateTabRemoteStatus(msg.ptyId, msg.remoteViewable);
}

// 添加更新标签状态的方法
updateTabRemoteStatus(ptyId, isRemoteViewable) {
    const tab = document.querySelector(`.tab[data-pty-id="${ptyId}"]`);
    if (tab) {
        if (isRemoteViewable) {
            tab.classList.add('remote-viewable');
        } else {
            tab.classList.remove('remote-viewable');
        }
    }
}

// 在 handlePtyList 中处理 remoteViewable 属性
handlePtyList(data) {
    const list = JSON.parse(data);
    if (list && list.length > 0) {
        list.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
        list.forEach((ptyInfo, index) => {
            if (ptyInfo.alive) {
                this.attachPty(ptyInfo.id, ptyInfo.name, index === 0);
                this.terminalRemoteViewable.set(ptyInfo.id, ptyInfo.remoteViewable || false);
                this.updateTabRemoteStatus(ptyInfo.id, ptyInfo.remoteViewable || false);
            }
        });
        this.updateNextTerminalNumber();
    } else {
        this.createPty();
    }
}
```

添加样式：

```css
.tab.remote-viewable::before {
    content: '🌐';
    margin-right: 4px;
    font-size: 10px;
}
```

## 步骤 15：创建远端 Web 界面

**文件**: `src/main/resources/remote/index.html`

目录调整说明：
- 远端静态资源目录统一为 `remote/`（对应 `WebApplication` 的 `.setWebDir("remote")`）。
- 将 xterm 相关资源复制一份到 `src/main/resources/remote/lib/`，远端页面通过 `lib/...` 引用（不依赖本地 `local/` 目录）。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebCli Remote Terminal</title>
    <link rel="stylesheet" href="lib/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1e1e1e;
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .toolbar {
            background: #2d2d2d;
            padding: 8px 16px;
            display: flex;
            gap: 8px;
            align-items: center;
            border-bottom: 1px solid #404040;
        }
        .toolbar button {
            background: #0e639c;
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        .toolbar button:hover { background: #1177bb; }
        .title {
            color: #4ec9b0;
            font-size: 14px;
            font-weight: 500;
        }
        .tabs {
            display: flex;
            gap: 2px;
            margin-left: 16px;
        }
        .tab {
            background: #2d2d2d;
            color: #ccc;
            border: none;
            padding: 6px 16px;
            cursor: pointer;
            font-size: 13px;
            border-radius: 4px 4px 0 0;
        }
        .tab.active { background: #1e1e1e; color: #fff; }
        .tab .close {
            margin-left: 8px;
            opacity: 0.6;
        }
        .tab .close:hover { opacity: 1; }
        #terminal-container {
            flex: 1;
            padding: 8px;
        }
        .status {
            color: #888;
            font-size: 12px;
            margin-left: auto;
        }
        .status.connected { color: #4ec9b0; }
        .status.disconnected { color: #f14c4c; }
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #888;
        }
        .empty-state h2 { margin-bottom: 8px; }
    </style>
</head>
<body>
<div class="toolbar">
    <span class="title">🌐 远程终端</span>
    <button id="btn-refresh">刷新列表</button>
    <div class="tabs" id="tabs"></div>
    <span class="status disconnected" id="status">未连接</span>
</div>
<div id="terminal-container">
    <div class="empty-state" id="empty-state">
        <h2>暂无可用终端</h2>
        <p>等待本地 Agent 共享终端...</p>
    </div>
</div>

<script src="lib/xterm.min.js"></script>
<script src="lib/xterm-addon-fit.min.js"></script>
<script>
    const MessageType = {
        PTY_OUTPUT: 'PTY_OUTPUT',
        PTY_INPUT: 'PTY_INPUT',
        PTY_RESIZE: 'PTY_RESIZE',
        PTY_CLOSE: 'PTY_CLOSE',
        PTY_ATTACH: 'PTY_ATTACH',
        PTY_REMOTE_LIST: 'PTY_REMOTE_LIST',
        ERROR: 'ERROR',
        SUCCESS: 'SUCCESS'
    };

    class RemoteTerminal {
        constructor() {
            this.ws = null;
            this.terminals = new Map();
            this.fitAddons = new Map();
            this.terminalNames = new Map();
            this.currentPtyId = null;

            this.init();
        }

        init() {
            this.connect();
            document.getElementById('btn-refresh').addEventListener('click', () => this.refreshList());
            window.addEventListener('resize', () => this.fitTerminal());
        }

        connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${location.host}/ws`;
            this.ws = new WebSocket(wsUrl);

            this.ws.onopen = () => {
                this.updateStatus(true);
                this.refreshList();
            };

            this.ws.onmessage = (e) => {
                this.handleMessage(JSON.parse(e.data));
            };

            this.ws.onclose = () => {
                this.updateStatus(false);
                setTimeout(() => this.connect(), 3000);
            };

            this.ws.onerror = (e) => console.error('WebSocket error:', e);
        }

        handleMessage(msg) {
            switch (msg.type) {
                case MessageType.PTY_OUTPUT:
                    const term = this.terminals.get(msg.ptyId);
                    if (term && msg.data) {
                        const decoded = atob(msg.data);
                        const bytes = Uint8Array.from(decoded, c => c.charCodeAt(0));
                        const text = new TextDecoder('utf-8').decode(bytes);
                        term.write(text);
                    }
                    break;
                case MessageType.PTY_REMOTE_LIST:
                    this.handlePtyList(msg.data);
                    break;
                case MessageType.SUCCESS:
                    if (msg.ptyId && !this.terminals.has(msg.ptyId)) {
                        // 附加成功后的处理在 attachPty 中完成
                    }
                    break;
                case MessageType.ERROR:
                    console.error('Server error:', msg.data);
                    break;
            }
        }

        handlePtyList(data) {
            const list = JSON.parse(data);
            const emptyState = document.getElementById('empty-state');

            if (list && list.length > 0) {
                emptyState.style.display = 'none';

                // 清除已不存在的终端
                const ptyIds = new Set(list.map(p => p.id));
                for (const [id] of this.terminals) {
                    if (!ptyIds.has(id)) {
                        this.removeTerminal(id);
                    }
                }

                // 添加新终端
                list.forEach((ptyInfo, index) => {
                    if (!this.terminals.has(ptyInfo.id)) {
                        this.attachPty(ptyInfo.id, ptyInfo.name, this.terminals.size === 0);
                    }
                });
            } else {
                emptyState.style.display = 'flex';
            }
        }

        refreshList() {
            this.send({ type: MessageType.PTY_REMOTE_LIST });
        }

        attachPty(ptyId, name, switchTo) {
            const term = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: '"Maple Mono NF", "MesloLGS NF", "Hack Nerd Font", Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#1e1e1e',
                    foreground: '#d4d4d4'
                }
            });

            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            this.terminals.set(ptyId, term);
            this.fitAddons.set(ptyId, fitAddon);
            this.terminalNames.set(ptyId, name);

            term.onData(data => {
                const encoded = btoa(unescape(encodeURIComponent(data)));
                this.send({ type: MessageType.PTY_INPUT, ptyId, data: encoded });
            });

            term.onResize(({ cols, rows }) => {
                this.send({ type: MessageType.PTY_RESIZE, ptyId, cols, rows });
            });

            this.addTab(ptyId, name);
            this.send({ type: MessageType.PTY_ATTACH, ptyId });

            if (switchTo) {
                this.switchTerminal(ptyId);
            }
        }

        addTab(ptyId, name) {
            const tabs = document.getElementById('tabs');
            const tab = document.createElement('button');
            tab.className = 'tab';
            tab.dataset.ptyId = ptyId;
            tab.innerHTML = `<span class="tab-name">${name}</span><span class="close">×</span>`;

            tab.addEventListener('click', (e) => {
                if (e.target.classList.contains('close')) {
                    this.closePty(ptyId);
                } else {
                    this.switchTerminal(ptyId);
                }
            });

            tabs.appendChild(tab);
        }

        switchTerminal(ptyId) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[data-pty-id="${ptyId}"]`)?.classList.add('active');

            const container = document.getElementById('terminal-container');
            container.innerHTML = '';

            const term = this.terminals.get(ptyId);
            const fitAddon = this.fitAddons.get(ptyId);
            if (term && fitAddon) {
                term.open(container);
                fitAddon.fit();
                term.focus();
                this.currentPtyId = ptyId;

                this.send({
                    type: MessageType.PTY_RESIZE,
                    ptyId,
                    cols: term.cols,
                    rows: term.rows
                });
            }
        }

        closePty(ptyId) {
            this.send({ type: MessageType.PTY_CLOSE, ptyId });
            this.removeTerminal(ptyId);
        }

        removeTerminal(ptyId) {
            this.terminals.get(ptyId)?.dispose();
            this.terminals.delete(ptyId);
            this.fitAddons.delete(ptyId);
            this.terminalNames.delete(ptyId);

            document.querySelector(`.tab[data-pty-id="${ptyId}"]`)?.remove();

            if (this.currentPtyId === ptyId) {
                const firstPty = this.terminals.keys().next().value;
                if (firstPty) {
                    this.switchTerminal(firstPty);
                } else {
                    document.getElementById('empty-state').style.display = 'flex';
                }
            }
        }

        fitTerminal() {
            if (this.currentPtyId) {
                const fitAddon = this.fitAddons.get(this.currentPtyId);
                const term = this.terminals.get(this.currentPtyId);
                if (fitAddon && term) {
                    fitAddon.fit();
                    this.send({
                        type: MessageType.PTY_RESIZE,
                        ptyId: this.currentPtyId,
                        cols: term.cols,
                        rows: term.rows
                    });
                }
            }
        }

        send(msg) {
            if (this.ws?.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify(msg));
            }
        }

        updateStatus(connected) {
            const status = document.getElementById('status');
            status.textContent = connected ? '已连接' : '未连接';
            status.className = `status ${connected ? 'connected' : 'disconnected'}`;
        }
    }

    new RemoteTerminal();
</script>
</body>
</html>
```

# 待办列表

1. 扩展配置类 WebCliConfig，添加运行模式、Token(PSK)、服务器地址等配置项
2. 扩展 PtyInstance 类，添加 remoteViewable 属性和多输出监听器支持
3. 扩展消息类型枚举 MessageType，添加 PTY_SET_REMOTE_VIEWABLE 和 PTY_REMOTE_LIST
4. 扩展 WsMessage 和 PtyInfo 类，添加 remoteViewable 字段
5. 创建 TCP 通信协议类 TcpMessageType 和 TcpMessage（包含握手字段与 AUTH_FINISH）
6. 创建加密工具类 AesGcmCrypto（会话密钥加密）
7. 创建 Agent TCP 客户端 AgentTcpClient（PSK+随机数+X25519 握手，不明文发送 Token）
8. 创建远端服务器 TCP 处理器 ServerTcpHandler（校验握手并在 AUTH_FINISH 后注册 Agent）
9. 创建 Agent 管理器 AgentManager
10. 创建远端 WebSocket 处理器 RemoteWebSocketHandler
11. 扩展 WebSocketHandler，处理设置远程可见的消息，修改为使用多输出监听器
12. 修改 WebApplication，支持 Agent 和 Server 双模式启动
13. 更新本地前端界面 `local/index.html`，并复制 xterm 资源到 `local/lib/`
14. 创建远端 Web 界面 `remote/index.html`，并复制 xterm 资源到 `remote/lib/`

# 需要修改或新增的类

## 需要修改的类

1. `cc.jfire.webcli.config.WebCliConfig` - 添加运行模式、Token(PSK)、服务器地址等配置
2. `cc.jfire.webcli.pty.PtyInstance` - 添加 remoteViewable 属性，将单个 outputConsumer 改为多输出监听器列表
3. `cc.jfire.webcli.protocol.MessageType` - 添加新消息类型
4. `cc.jfire.webcli.protocol.WsMessage` - 添加 remoteViewable 字段
5. `cc.jfire.webcli.protocol.PtyInfo` - 添加 remoteViewable 字段和新构造函数
6. `cc.jfire.webcli.web.WebSocketHandler` - 处理设置远程可见的消息，修改为使用多输出监听器
7. `cc.jfire.webcli.WebApplication` - 支持双模式启动

## 需要新增的类

1. `cc.jfire.webcli.protocol.TcpMessageType` - TCP 消息类型枚举
2. `cc.jfire.webcli.protocol.TcpMessage` - TCP 消息数据结构
3. `cc.jfire.webcli.crypto.AesGcmCrypto` - AES-GCM 加密工具类
4. `cc.jfire.webcli.agent.AgentTcpClient` - Agent 端 TCP 客户端
5. `cc.jfire.webcli.server.ServerTcpHandler` - Server 端 TCP 处理器
6. `cc.jfire.webcli.server.AgentManager` - Agent 连接管理器
7. `cc.jfire.webcli.server.RemoteWebSocketHandler` - 远端 WebSocket 处理器

## 需要新增或修改的前端文件

1. `src/main/resources/local/index.html` - 添加"设置可远程查看"菜单
2. `src/main/resources/local/lib/` - 本地 xterm 静态资源（复制一份）
3. `src/main/resources/remote/index.html` - 新建远端 Web 界面
4. `src/main/resources/remote/lib/` - 远端 xterm 静态资源（复制一份）
