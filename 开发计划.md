# 目标

1. 基于《需求文档》和《总体计划》，完成 P0 相关内容。
2. P0 范围：仅本地 Agent（PTY 管理 + 本地 Web 服务），不包含远端 WebServer。

# 核心思路

1. **PTY 管理模块**：使用 pty4j 库创建和管理伪终端，每个 PTY 实例包含输入输出流和窗口大小信息。
2. **本地 Web 服务**：使用 JfireBoot 框架启动 HTTP 服务，绑定 127.0.0.1，提供 WebSocket 端点与前端通信。
3. **WebSocket 通信**：使用 Jnet 框架的 WebSocket 支持，处理终端输入输出和 PTY 管理指令。
4. **基础前端**：使用 xterm.js 实现终端界面，通过 WebSocket 与后端通信。
5. **TCP 协议基础**：定义消息协议和消息类，使用 JfireSE 进行二进制序列化，为后续远端通信做准备。

# 详细实现思路

## 1. 项目依赖配置
- 在 pom.xml 中添加 pty4j 依赖

## 2. PTY 管理模块 (`cc.jfire.webcli.pty`)
- **PtyInstance**：封装单个 PTY 实例，包含 PtyProcess、输入输出流、窗口大小
- **PtyManager**：管理多个 PTY 实例的创建、销毁和查询

## 3. 消息协议定义 (`cc.jfire.webcli.protocol`)
- 定义消息类型枚举和各类消息体
- 使用 JfireSE 进行序列化/反序列化

## 4. 本地 Web 服务 (`cc.jfire.webcli.web`)
- 启动 HTTP 服务，提供静态资源访问
- WebSocket 端点处理：终端输入输出、PTY 管理指令

## 5. 前端页面 (`src/main/resources/web`)
- 终端页面：xterm.js 集成、WebSocket 连接
- PTY 管理界面：创建、切换、关闭 PTY

# 实施步骤

## 步骤 1：添加 pty4j 依赖

在 `pom.xml` 的 `<dependencies>` 中添加：

```xml
<dependency>
    <groupId>org.jetbrains.pty4j</groupId>
    <artifactId>pty4j</artifactId>
    <version>0.13.4</version>
</dependency>
```

## 步骤 2：创建 PTY 管理类

### 2.1 创建 `cc.jfire.webcli.pty.PtyInstance` 类

```java
package cc.jfire.webcli.pty;

import com.pty4j.PtyProcess;
import com.pty4j.PtyProcessBuilder;
import com.pty4j.WinSize;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Consumer;

@Slf4j
@Getter
public class PtyInstance {
    private final String id;
    private final PtyProcess process;
    private final BufferedReader reader;
    private final OutputStreamWriter writer;
    private volatile boolean running = true;
    private Consumer<String> outputConsumer;
    private Thread readThread;

    public PtyInstance(String[] command) throws IOException {
        this.id = UUID.randomUUID().toString();
        Map<String, String> env = new HashMap<>(System.getenv());
        env.put("TERM", "xterm-256color");

        this.process = new PtyProcessBuilder()
                .setCommand(command)
                .setEnvironment(env)
                .start();

        this.reader = new BufferedReader(new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8));
        this.writer = new OutputStreamWriter(process.getOutputStream(), StandardCharsets.UTF_8);
    }

    public void setOutputConsumer(Consumer<String> consumer) {
        this.outputConsumer = consumer;
    }

    public void startReading() {
        readThread = Thread.startVirtualThread(() -> {
            try {
                char[] buffer = new char[1024];
                int len;
                while (running && (len = reader.read(buffer)) != -1) {
                    String output = new String(buffer, 0, len);
                    if (outputConsumer != null) {
                        outputConsumer.accept(output);
                    }
                }
            } catch (IOException e) {
                if (running) {
                    log.error("读取 PTY 输出失败", e);
                }
            }
        });
    }

    public void write(String input) throws IOException {
        writer.write(input);
        writer.flush();
    }

    public void resize(int cols, int rows) {
        process.setWinSize(new WinSize(cols, rows));
    }

    public void close() {
        running = false;
        try {
            writer.close();
            reader.close();
        } catch (IOException e) {
            log.error("关闭 PTY 流失败", e);
        }
        process.destroy();
    }

    public boolean isAlive() {
        return process.isAlive();
    }
}
```

### 2.2 创建 `cc.jfire.webcli.pty.PtyManager` 类

```java
package cc.jfire.webcli.pty;

import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.util.Collection;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
public class PtyManager {
    private final ConcurrentHashMap<String, PtyInstance> instances = new ConcurrentHashMap<>();
    private final String[] defaultCommand;

    public PtyManager() {
        String os = System.getProperty("os.name").toLowerCase();
        if (os.contains("win")) {
            this.defaultCommand = new String[]{"cmd.exe"};
        } else {
            this.defaultCommand = new String[]{"/bin/bash", "-l"};
        }
    }

    public PtyInstance create() throws IOException {
        return create(defaultCommand);
    }

    public PtyInstance create(String[] command) throws IOException {
        PtyInstance instance = new PtyInstance(command);
        instances.put(instance.getId(), instance);
        log.info("创建 PTY 实例: {}", instance.getId());
        return instance;
    }

    public PtyInstance get(String id) {
        return instances.get(id);
    }

    public void remove(String id) {
        PtyInstance instance = instances.remove(id);
        if (instance != null) {
            instance.close();
            log.info("移除 PTY 实例: {}", id);
        }
    }

    public Collection<PtyInstance> getAll() {
        return instances.values();
    }

    public void shutdown() {
        for (PtyInstance instance : instances.values()) {
            instance.close();
        }
        instances.clear();
    }
}
```

## 步骤 3：定义消息协议类

### 3.1 创建 `cc.jfire.webcli.protocol.MessageType` 枚举

```java
package cc.jfire.webcli.protocol;

public enum MessageType {
    // PTY 相关
    PTY_OUTPUT,      // 终端输出
    PTY_INPUT,       // 终端输入
    PTY_RESIZE,      // 终端大小调整
    PTY_CREATE,      // 创建 PTY
    PTY_CLOSE,       // 关闭 PTY
    PTY_LIST,        // PTY 列表
    PTY_SWITCH,      // 切换 PTY

    // 系统消息
    ERROR,           // 错误信息
    SUCCESS          // 成功响应
}
```

### 3.2 创建 `cc.jfire.webcli.protocol.WsMessage` 消息基类

```java
package cc.jfire.webcli.protocol;

import lombok.Data;

@Data
public class WsMessage {
    private MessageType type;
    private String ptyId;
    private String data;
    private Integer cols;
    private Integer rows;
}
```

### 3.3 创建 `cc.jfire.webcli.protocol.PtyInfo` 类

```java
package cc.jfire.webcli.protocol;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PtyInfo {
    private String id;
    private boolean alive;
}
```

## 步骤 4：实现 WebSocket 处理器

### 4.1 创建 `cc.jfire.webcli.web.WebSocketHandler` 类

```java
package cc.jfire.webcli.web;

import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.common.api.ReadProcessor;
import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.extend.http.dto.WebSocketFrame;
import cc.jfire.webcli.protocol.MessageType;
import cc.jfire.webcli.protocol.PtyInfo;
import cc.jfire.webcli.protocol.WsMessage;
import cc.jfire.webcli.pty.PtyInstance;
import cc.jfire.webcli.pty.PtyManager;
import com.alibaba.fastjson2.JSON;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
public class WebSocketHandler implements ReadProcessor<WebSocketFrame> {
    private final PtyManager ptyManager;
    private final ConcurrentHashMap<Pipeline, String> pipelinePtyMap = new ConcurrentHashMap<>();

    public WebSocketHandler(PtyManager ptyManager) {
        this.ptyManager = ptyManager;
    }

    @Override
    public void read(WebSocketFrame frame, ReadProcessorNode next) {
        Pipeline pipeline = next.pipeline();

        if (frame.getOpcode() == WebSocketFrame.OPCODE_CLOSE) {
            handleClose(pipeline);
            return;
        }

        if (frame.getOpcode() == WebSocketFrame.OPCODE_TEXT) {
            String text = new String(frame.getPayload().readableArray(), StandardCharsets.UTF_8);
            handleMessage(pipeline, text);
        }
    }

    private void handleMessage(Pipeline pipeline, String text) {
        try {
            WsMessage msg = JSON.parseObject(text, WsMessage.class);
            switch (msg.getType()) {
                case PTY_CREATE -> handlePtyCreate(pipeline);
                case PTY_INPUT -> handlePtyInput(pipeline, msg);
                case PTY_RESIZE -> handlePtyResize(pipeline, msg);
                case PTY_CLOSE -> handlePtyClose(pipeline, msg);
                case PTY_LIST -> handlePtyList(pipeline);
                case PTY_SWITCH -> handlePtySwitch(pipeline, msg);
                default -> log.warn("未知消息类型: {}", msg.getType());
            }
        } catch (Exception e) {
            log.error("处理消息失败", e);
            sendError(pipeline, e.getMessage());
        }
    }

    private void handlePtyCreate(Pipeline pipeline) throws IOException {
        PtyInstance pty = ptyManager.create();
        pipelinePtyMap.put(pipeline, pty.getId());

        pty.setOutputConsumer(output -> {
            WsMessage msg = new WsMessage();
            msg.setType(MessageType.PTY_OUTPUT);
            msg.setPtyId(pty.getId());
            msg.setData(output);
            sendMessage(pipeline, msg);
        });
        pty.startReading();

        WsMessage response = new WsMessage();
        response.setType(MessageType.SUCCESS);
        response.setPtyId(pty.getId());
        sendMessage(pipeline, response);
    }

    private void handlePtyInput(Pipeline pipeline, WsMessage msg) throws IOException {
        String ptyId = msg.getPtyId() != null ? msg.getPtyId() : pipelinePtyMap.get(pipeline);
        PtyInstance pty = ptyManager.get(ptyId);
        if (pty != null) {
            pty.write(msg.getData());
        }
    }

    private void handlePtyResize(Pipeline pipeline, WsMessage msg) {
        String ptyId = msg.getPtyId() != null ? msg.getPtyId() : pipelinePtyMap.get(pipeline);
        PtyInstance pty = ptyManager.get(ptyId);
        if (pty != null && msg.getCols() != null && msg.getRows() != null) {
            pty.resize(msg.getCols(), msg.getRows());
        }
    }

    private void handlePtyClose(Pipeline pipeline, WsMessage msg) {
        String ptyId = msg.getPtyId() != null ? msg.getPtyId() : pipelinePtyMap.get(pipeline);
        if (ptyId != null) {
            ptyManager.remove(ptyId);
            pipelinePtyMap.remove(pipeline);

            WsMessage response = new WsMessage();
            response.setType(MessageType.SUCCESS);
            sendMessage(pipeline, response);
        }
    }

    private void handlePtyList(Pipeline pipeline) {
        List<PtyInfo> list = ptyManager.getAll().stream()
                .map(pty -> new PtyInfo(pty.getId(), pty.isAlive()))
                .toList();

        WsMessage response = new WsMessage();
        response.setType(MessageType.PTY_LIST);
        response.setData(JSON.toJSONString(list));
        sendMessage(pipeline, response);
    }

    private void handlePtySwitch(Pipeline pipeline, WsMessage msg) {
        PtyInstance pty = ptyManager.get(msg.getPtyId());
        if (pty != null) {
            pipelinePtyMap.put(pipeline, msg.getPtyId());

            WsMessage response = new WsMessage();
            response.setType(MessageType.SUCCESS);
            response.setPtyId(msg.getPtyId());
            sendMessage(pipeline, response);
        } else {
            sendError(pipeline, "PTY 不存在: " + msg.getPtyId());
        }
    }

    private void handleClose(Pipeline pipeline) {
        pipelinePtyMap.remove(pipeline);
    }

    private void sendMessage(Pipeline pipeline, WsMessage msg) {
        String json = JSON.toJSONString(msg);
        WebSocketFrame frame = new WebSocketFrame();
        frame.setOpcode(WebSocketFrame.OPCODE_TEXT);
        frame.setPayload(pipeline.allocator().allocate(json.getBytes(StandardCharsets.UTF_8)));
        pipeline.fireWrite(frame);
    }

    private void sendError(Pipeline pipeline, String error) {
        WsMessage msg = new WsMessage();
        msg.setType(MessageType.ERROR);
        msg.setData(error);
        sendMessage(pipeline, msg);
    }

    @Override
    public void readFailed(Throwable e, ReadProcessorNode next) {
        log.error("WebSocket 读取失败", e);
    }

    @Override
    public void readCompleted(ReadProcessorNode next) {
        handleClose(next.pipeline());
    }
}
```

## 步骤 5：实现应用启动类

### 5.1 创建 `cc.jfire.webcli.WebCliApplication` 类

```java
package cc.jfire.webcli;

import cc.jfire.boot.http.HttpAppServer;
import cc.jfire.codejson.JsonTool;
import cc.jfire.jfire.ApplicationContext;
import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.common.util.ChannelConfig;
import cc.jfire.jnet.extend.http.coder.HttpRequestAggregator;
import cc.jfire.jnet.extend.http.coder.HttpRequestPartDecoder;
import cc.jfire.jnet.extend.websocket.WebSocketFrameDecoder;
import cc.jfire.jnet.extend.websocket.WebSocketFrameEncoder;
import cc.jfire.jnet.extend.websocket.WebSocketUpgradeDecoder;
import cc.jfire.jnet.server.AioServer;
import cc.jfire.webcli.pty.PtyManager;
import cc.jfire.webcli.web.WebSocketHandler;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class WebCliApplication {
    private static final int DEFAULT_PORT = 18080;

    private final int port;
    private final PtyManager ptyManager;
    private AioServer server;

    public WebCliApplication(int port) {
        this.port = port;
        this.ptyManager = new PtyManager();
    }

    public void start() {
        ApplicationContext context = new ApplicationContext();

        ChannelConfig config = new ChannelConfig()
                .setPort(port)
                .setChannelGroup(ChannelConfig.DEFAULT_CHANNEL_GROUP);

        WebSocketHandler wsHandler = new WebSocketHandler(ptyManager);

        server = AioServer.newAioServer(config, pipeline -> {
            pipeline.addReadProcessor(new HttpRequestPartDecoder());
            pipeline.addReadProcessor(new HttpRequestAggregator());
            pipeline.addReadProcessor(new WebSocketUpgradeDecoder());
            pipeline.addReadProcessor(new WebSocketFrameDecoder());
            pipeline.addReadProcessor(wsHandler);
            pipeline.addWriteProcessor(new WebSocketFrameEncoder());
        });

        server.start();
        log.info("WebCli 服务已启动，端口: {}", port);
        log.info("请访问: http://127.0.0.1:{}/", port);
    }

    public void shutdown() {
        if (server != null) {
            server.shutdown();
        }
        ptyManager.shutdown();
        log.info("WebCli 服务已关闭");
    }

    public static void main(String[] args) {
        int port = DEFAULT_PORT;
        if (args.length > 0) {
            try {
                port = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                log.warn("无效的端口参数，使用默认端口: {}", DEFAULT_PORT);
            }
        }

        WebCliApplication app = new WebCliApplication(port);

        Runtime.getRuntime().addShutdownHook(new Thread(app::shutdown));

        app.start();
    }
}
```

## 步骤 6：创建前端页面

### 6.1 创建 `src/main/resources/web/index.html`

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebCli Terminal</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1e1e1e;
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .toolbar {
            background: #2d2d2d;
            padding: 8px 16px;
            display: flex;
            gap: 8px;
            align-items: center;
            border-bottom: 1px solid #404040;
        }
        .toolbar button {
            background: #0e639c;
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        .toolbar button:hover { background: #1177bb; }
        .toolbar button:disabled { background: #555; cursor: not-allowed; }
        .tabs {
            display: flex;
            gap: 2px;
            margin-left: 16px;
        }
        .tab {
            background: #2d2d2d;
            color: #ccc;
            border: none;
            padding: 6px 16px;
            cursor: pointer;
            font-size: 13px;
            border-radius: 4px 4px 0 0;
        }
        .tab.active { background: #1e1e1e; color: #fff; }
        .tab .close {
            margin-left: 8px;
            opacity: 0.6;
        }
        .tab .close:hover { opacity: 1; }
        #terminal-container {
            flex: 1;
            padding: 8px;
        }
        .status {
            color: #888;
            font-size: 12px;
            margin-left: auto;
        }
        .status.connected { color: #4ec9b0; }
        .status.disconnected { color: #f14c4c; }
    </style>
</head>
<body>
    <div class="toolbar">
        <button id="btn-new">新建终端</button>
        <div class="tabs" id="tabs"></div>
        <span class="status disconnected" id="status">未连接</span>
    </div>
    <div id="terminal-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script>
        const MessageType = {
            PTY_OUTPUT: 'PTY_OUTPUT',
            PTY_INPUT: 'PTY_INPUT',
            PTY_RESIZE: 'PTY_RESIZE',
            PTY_CREATE: 'PTY_CREATE',
            PTY_CLOSE: 'PTY_CLOSE',
            PTY_LIST: 'PTY_LIST',
            PTY_SWITCH: 'PTY_SWITCH',
            ERROR: 'ERROR',
            SUCCESS: 'SUCCESS'
        };

        class WebCliTerminal {
            constructor() {
                this.ws = null;
                this.terminals = new Map();
                this.currentPtyId = null;
                this.fitAddon = new FitAddon.FitAddon();

                this.init();
            }

            init() {
                this.connect();

                document.getElementById('btn-new').addEventListener('click', () => this.createPty());
                window.addEventListener('resize', () => this.fitTerminal());
            }

            connect() {
                const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                this.ws = new WebSocket(`${protocol}//${location.host}/ws`);

                this.ws.onopen = () => {
                    this.updateStatus(true);
                    this.createPty();
                };

                this.ws.onmessage = (e) => this.handleMessage(JSON.parse(e.data));

                this.ws.onclose = () => {
                    this.updateStatus(false);
                    setTimeout(() => this.connect(), 3000);
                };

                this.ws.onerror = (e) => console.error('WebSocket error:', e);
            }

            handleMessage(msg) {
                switch (msg.type) {
                    case MessageType.PTY_OUTPUT:
                        const term = this.terminals.get(msg.ptyId);
                        if (term) term.write(msg.data);
                        break;
                    case MessageType.SUCCESS:
                        if (msg.ptyId && !this.terminals.has(msg.ptyId)) {
                            this.addTerminal(msg.ptyId);
                        }
                        break;
                    case MessageType.ERROR:
                        console.error('Server error:', msg.data);
                        break;
                }
            }

            createPty() {
                this.send({ type: MessageType.PTY_CREATE });
            }

            addTerminal(ptyId) {
                const term = new Terminal({
                    cursorBlink: true,
                    fontSize: 14,
                    fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                    theme: {
                        background: '#1e1e1e',
                        foreground: '#d4d4d4'
                    }
                });

                term.loadAddon(this.fitAddon);
                this.terminals.set(ptyId, term);

                term.onData(data => {
                    this.send({ type: MessageType.PTY_INPUT, ptyId, data });
                });

                term.onResize(({ cols, rows }) => {
                    this.send({ type: MessageType.PTY_RESIZE, ptyId, cols, rows });
                });

                this.addTab(ptyId);
                this.switchTerminal(ptyId);
            }

            addTab(ptyId) {
                const tabs = document.getElementById('tabs');
                const tab = document.createElement('button');
                tab.className = 'tab';
                tab.dataset.ptyId = ptyId;
                tab.innerHTML = `终端 ${this.terminals.size}<span class="close">×</span>`;

                tab.addEventListener('click', (e) => {
                    if (e.target.classList.contains('close')) {
                        this.closePty(ptyId);
                    } else {
                        this.switchTerminal(ptyId);
                    }
                });

                tabs.appendChild(tab);
            }

            switchTerminal(ptyId) {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelector(`.tab[data-pty-id="${ptyId}"]`)?.classList.add('active');

                const container = document.getElementById('terminal-container');
                container.innerHTML = '';

                const term = this.terminals.get(ptyId);
                if (term) {
                    term.open(container);
                    this.fitAddon.fit();
                    term.focus();
                    this.currentPtyId = ptyId;

                    this.send({
                        type: MessageType.PTY_RESIZE,
                        ptyId,
                        cols: term.cols,
                        rows: term.rows
                    });
                }
            }

            closePty(ptyId) {
                this.send({ type: MessageType.PTY_CLOSE, ptyId });
                this.terminals.get(ptyId)?.dispose();
                this.terminals.delete(ptyId);

                document.querySelector(`.tab[data-pty-id="${ptyId}"]`)?.remove();

                if (this.currentPtyId === ptyId) {
                    const firstPty = this.terminals.keys().next().value;
                    if (firstPty) this.switchTerminal(firstPty);
                }
            }

            fitTerminal() {
                if (this.currentPtyId) {
                    this.fitAddon.fit();
                    const term = this.terminals.get(this.currentPtyId);
                    if (term) {
                        this.send({
                            type: MessageType.PTY_RESIZE,
                            ptyId: this.currentPtyId,
                            cols: term.cols,
                            rows: term.rows
                        });
                    }
                }
            }

            send(msg) {
                if (this.ws?.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(msg));
                }
            }

            updateStatus(connected) {
                const status = document.getElementById('status');
                status.textContent = connected ? '已连接' : '未连接';
                status.className = `status ${connected ? 'connected' : 'disconnected'}`;
            }
        }

        new WebCliTerminal();
    </script>
</body>
</html>
```

## 步骤 7：添加静态资源处理

### 7.1 修改 `WebCliApplication` 支持静态资源

修改 `WebCliApplication.java` 的 `start()` 方法，添加对静态资源和 HTTP 请求的支持：

```java
public void start() {
    ApplicationContext context = new ApplicationContext();

    WebSocketHandler wsHandler = new WebSocketHandler(ptyManager);

    server = HttpAppServer.start(
            port,
            context,
            "web",  // 静态资源目录，相对于 classpath
            new WebSocketUpgradeProcessor(wsHandler)
    );

    log.info("WebCli 服务已启动，端口: {}", port);
    log.info("请访问: http://127.0.0.1:{}/", port);
}
```

### 7.2 创建 `cc.jfire.webcli.web.WebSocketUpgradeProcessor` 类

```java
package cc.jfire.webcli.web;

import cc.jfire.jnet.common.api.Pipeline;
import cc.jfire.jnet.common.api.ReadProcessor;
import cc.jfire.jnet.common.api.ReadProcessorNode;
import cc.jfire.jnet.extend.http.dto.HttpRequest;
import cc.jfire.jnet.extend.websocket.WebSocketFrameDecoder;
import cc.jfire.jnet.extend.websocket.WebSocketFrameEncoder;
import cc.jfire.jnet.extend.websocket.WebSocketHandshakeUtil;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class WebSocketUpgradeProcessor implements ReadProcessor<HttpRequest> {
    private final WebSocketHandler wsHandler;

    public WebSocketUpgradeProcessor(WebSocketHandler wsHandler) {
        this.wsHandler = wsHandler;
    }

    @Override
    public void read(HttpRequest request, ReadProcessorNode next) {
        String path = request.getHead().getPath();
        String upgrade = request.getHead().getHeaders().get("Upgrade");

        if ("/ws".equals(path) && "websocket".equalsIgnoreCase(upgrade)) {
            Pipeline pipeline = next.pipeline();

            // 发送 WebSocket 握手响应
            String key = request.getHead().getHeaders().get("Sec-WebSocket-Key");
            byte[] response = WebSocketHandshakeUtil.buildHandshakeResponse(key);
            pipeline.fireWrite(response);

            // 切换到 WebSocket 处理链
            pipeline.addReadProcessor(new WebSocketFrameDecoder());
            pipeline.addReadProcessor(wsHandler);
            pipeline.addWriteProcessor(new WebSocketFrameEncoder());

            log.info("WebSocket 连接已建立: {}", path);
        } else {
            next.read(request);
        }
    }
}
```

# 待办列表

1. 添加 pty4j 依赖到 pom.xml
2. 创建 PTY 管理模块（PtyInstance、PtyManager）
3. 创建消息协议类（MessageType、WsMessage、PtyInfo）
4. 创建 WebSocket 处理器（WebSocketHandler、WebSocketUpgradeProcessor）
5. 创建应用启动类（WebCliApplication）
6. 创建前端页面（index.html）

# 需要修改或新增的类

## 修改的文件
1. `pom.xml` - 添加 pty4j 依赖

## 新增的类
1. `cc.jfire.webcli.pty.PtyInstance` - PTY 实例封装
2. `cc.jfire.webcli.pty.PtyManager` - PTY 管理器
3. `cc.jfire.webcli.protocol.MessageType` - 消息类型枚举
4. `cc.jfire.webcli.protocol.WsMessage` - WebSocket 消息类
5. `cc.jfire.webcli.protocol.PtyInfo` - PTY 信息类
6. `cc.jfire.webcli.web.WebSocketHandler` - WebSocket 消息处理器
7. `cc.jfire.webcli.web.WebSocketUpgradeProcessor` - WebSocket 升级处理器
8. `cc.jfire.webcli.WebCliApplication` - 应用启动类

## 新增的资源文件
1. `src/main/resources/web/index.html` - 前端终端页面